<!DOCTYPE html>

<html>
<head>
  <title>Interrupt</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>

      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page_wrapper">
            <div id="jump_page">


                <a class="source" href="interrupt.js.html">
                  interrupt.js
                </a>


                <a class="source" href="location.js.html">
                  location.js
                </a>


                <a class="source" href="readme.t.js.html">
                  readme.t.js
                </a>

            </div>
          </div>
        </li>
      </ul>

    <ul class="sections">



        <li id="section-1">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1 id="interrupt">Interrupt</h1>

            </div>

        </li>


        <li id="section-2">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p><strong>TODO</strong> Currently making a pass to fix the English, also organize the
sections so that they build on each. Will follow with pass to ensure that all
the unit tests (calls to <code>okay</code>) have meaningful descriptions.</p>

            </div>

        </li>


        <li id="section-3">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Exceptions are nice. I like the concept. I’ve always done my best to employ
them in JavaScript and Node.js but it isn’t always easy.</p>

            </div>

        </li>


        <li id="section-4">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Interrupt is a module I created to address the problems with JavaScript’s
limited exception mechanism, solving the numerous challenges I’ve encountered
that I’m sure you’ve encountered as well. It is not an elegant solution, but
it is a solution none the less.</p>

            </div>

        </li>


        <li id="section-5">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <h2 id="advocacy">Advocacy</h2>

            </div>

        </li>


        <li id="section-6">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Interrupt allows you to get exceptions that have a file name and line number
from your program, instead of a stubby stack trace that points to the
wilderness of the Node.js source, or <a href="https://github.com/nodejs/node/issues/30944">no stack trace at
all</a>. It does this with some
syntactical struggle, but without the expensive superfluous stack trace
generation of the long stack trace modules.</p>

            </div>

        </li>


        <li id="section-7">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Interrupt allows you to nest exceptions so you can provide application
context to system and library exceptions.</p>

            </div>

        </li>


        <li id="section-8">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Interrupt allows you to cite multiple nested exceptions as the cause of your
contextual exception which is necessary if you’re doing any sort of parallel
asynchronous programming where multiple parallel paths can raise exceptions.</p>

            </div>

        </li>


        <li id="section-9">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Interrupt uses and abuses the <code>Error.stack</code> property provided by Google V8 to
generate an elaborate report from <code>Error.stack</code> including the <code>Error</code> type,
message, context properties, and stack trace along with the error messages
and stack traces of all the nested errors.</p>

            </div>

        </li>


        <li id="section-10">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Interrupt’s elaborate <code>Error.stack</code> is machine readable so you could
conceivably process these stack traces programmatically after gathering them
from production logs.</p>

            </div>

        </li>


        <li id="section-11">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Interrupt can report it’s elaborate stack trace de-duped with a count of
similar exceptions so that when great many parallel operations raise the same
exception you don’t have wade through the repetitive stack traces to see if
there is anything unique about one of them.</p>

            </div>

        </li>


        <li id="section-12">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Interrupt endeavours to do all this with a minimum of extra code and code
paths so you can format exception messages with <code>sprintf-js</code>, set properties,
specify nested expressions the constructor, often as a one-liner. <strong>TODO</strong>
Basically advocating one-liners, poorly worded.</p>

            </div>

        </li>


        <li id="section-13">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <h2 id="running-the-readme">Running the Readme</h2>

            </div>

        </li>


        <li id="section-14">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>This readme document is a unit test from the Interrupt source code. It uses
the <a href="https://github.com/bigeasy/proof">Proof</a> unit test framework. We’ll be
using the <code>okay</code> method from Proof to assert the points we make about
Interrupt.</p>

            </div>

        </li>


        <li id="section-15">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Please run this test yourself.</p>
<pre><code class="language-text">git clone git@github.com:bigeasy/interrupt.git
cd interrupt
npm install --no-package-lock --no-save
node --async-stack-traces test/readme.t.js</code></pre>
<p>The only way to see the elaborate stack trace output is to run this test at
the command line, so please do so.</p>
<p>Interrupt is targeted for Node.js 12 or greater. Note that we are running
with <code>--async-stack-traces</code> enabled and to enjoy all the features discussed
in this readme you need to be running Node.js 14.</p>
<p>Out unit test begins here.</p>

            </div>

        </li>


        <li id="section-16">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-built_in">require</span>(<span class="hljs-string">'proof'</span>)(<span class="hljs-number">180</span>, <span class="hljs-keyword">async</span> okay =&gt; {</pre></div></div>

        </li>


        <li id="section-17">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>To use Interrupt install it from NPM using the following.</p>
<pre><code class="language-text">npm install interrupt</code></pre>
<p>Then you can begin to use it in your code as follows.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> Interrupt = <span class="hljs-built_in">require</span>(<span class="hljs-string">'interrupt'</span>)</code></pre>
<p>But here, because we’re in our project directory, we require Interrupt by
requiring the root of the project.</p>

            </div>

        </li>


        <li id="section-18">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">const</span> Interrupt = <span class="hljs-built_in">require</span>(<span class="hljs-string">'..'</span>)</pre></div></div>

        </li>


        <li id="section-19">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-20">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>In some our examples we’re going to pretent to load a config file. Here
we create a temporary directory with some good configs and some bad
configs.</p>

            </div>

        </li>


        <li id="section-21">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises

        <span class="hljs-keyword">const</span> tmp = path.join(__dirname, <span class="hljs-string">'tmp'</span>)

        <span class="hljs-keyword">await</span> fs.rmdir(tmp, { <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> })
        <span class="hljs-keyword">await</span> fs.mkdir(path.join(tmp, <span class="hljs-string">'eisdir'</span>, <span class="hljs-string">'config.json'</span>), { <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> })
        <span class="hljs-keyword">await</span> fs.mkdir(path.join(tmp, <span class="hljs-string">'enoent'</span>))
        <span class="hljs-keyword">await</span> fs.mkdir(path.join(tmp, <span class="hljs-string">'good'</span>))
        <span class="hljs-keyword">await</span> fs.mkdir(path.join(tmp, <span class="hljs-string">'bad'</span>))
        <span class="hljs-keyword">await</span> fs.mkdir(path.join(tmp, <span class="hljs-string">'create'</span>))

        <span class="hljs-keyword">await</span> fs.writeFile(path.join(tmp, <span class="hljs-string">'good'</span>, <span class="hljs-string">'config.json'</span>), <span class="hljs-built_in">JSON</span>.stringify({
            <span class="hljs-attr">settings</span>: {
                <span class="hljs-attr">volume</span>: <span class="hljs-number">0</span>
            }
        }))

        <span class="hljs-keyword">await</span> fs.writeFile(path.join(tmp, <span class="hljs-string">'bad'</span>, <span class="hljs-string">'config.json'</span>), <span class="hljs-string">'!'</span>)
    }</pre></div></div>

        </li>


        <li id="section-22">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-23">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>All of the examples in this code are <em>contrived</em>, and in practice, I’m
never quite this zealous with my use of exceptions or Interrupt.</p>

            </div>

        </li>


        <li id="section-24">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <h2 id="happy-path-vs-error-path">Happy Path vs Error Path</h2>

            </div>

        </li>


        <li id="section-25">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Throughout we’ll be referring to the happy path and the error path.</p>

            </div>

        </li>


        <li id="section-26">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>The happy path is the path of code execution where everything goes as
expected. It is the code path that gets the most exercise, the path that
receives the most robust testing.</p>

            </div>

        </li>


        <li id="section-27">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>The error path is the path of code excution that is followed when things
go sideways. One would hope that the error path is not often executed
during normal operation. One would expect the error path to be followed
as a result unforseen circumstances that might not have been considered
during development. Sadly, the error path usually does not receive a lot
of testing. One should tread lightly on the error path.</p>

            </div>

        </li>


        <li id="section-28">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Interrupt endevours to be exacting on the happy path and accommodating on
error path. It has a lot of assertions on functions that are executed
during normal operation and a lot of fallbacks on the functions that are
executed during exception handling.</p>

            </div>

        </li>


        <li id="section-29">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>When we speak of the error path in this documenation, we are urging
caution and justifing our accommodations. When we speak of the happy path
in this documentation we are urging rigor and justifying our assertions.</p>

            </div>

        </li>


        <li id="section-30">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <h2 id="errors-by-code">Errors by Code</h2>

            </div>

        </li>


        <li id="section-31">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Errors in JavaScript have very little context information. The only
properties defined by the spec are <code>name</code> and <code>message</code>.</p>

            </div>

        </li>


        <li id="section-32">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p><strong>TODO</strong> As of this writing, Interrupt is targeted for Node.js and Google
V8 only, but can probably be ported to other JavaScript engines if
someone would like to recommend a cross-browser development setup. I’m
open to porting if someone is interested.</p>

            </div>

        </li>


        <li id="section-33">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>The <code>message</code> is supposed to be human readable and because of this it
doesn’t serve well as a programmatic indication of error type.</p>

            </div>

        </li>


        <li id="section-34">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- message only Errors ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadJSONConfiguration</span> (<span class="hljs-params">filename</span>) </span>{
            <span class="hljs-keyword">let</span> json
            <span class="hljs-keyword">try</span> {
                json = <span class="hljs-keyword">await</span> fs.readFile(filename, <span class="hljs-string">''</span>)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">const</span> e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'file unreadable: '</span> + filename)
                e.cause = error
                <span class="hljs-keyword">throw</span> e
            }
            <span class="hljs-keyword">let</span> config
            <span class="hljs-keyword">try</span> {
                config = <span class="hljs-built_in">JSON</span>.parse(json)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">const</span> e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'unable to parse configuration'</span>)
                e.cause = error
                <span class="hljs-keyword">throw</span> e
            }
            <span class="hljs-keyword">if</span> (config == <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> config != <span class="hljs-string">'object'</span> || <span class="hljs-built_in">Array</span>.isArray(object)) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'JSON must be an object'</span>)
            }
            <span class="hljs-keyword">if</span> (config.size == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'memory is a require configuration parameter'</span>)
            }
            <span class="hljs-keyword">if</span> (config.size == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'memory configuration parameter must be a number'</span>)
            }
            <span class="hljs-keyword">return</span> config
        }

        <span class="hljs-keyword">let</span> config
        <span class="hljs-keyword">try</span> {
            config = <span class="hljs-keyword">await</span> loadJSONConfiguration(path.join(__dirname, <span class="hljs-string">'missing.txt'</span>))
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/file unreadable/</span>.test(error.message) &amp;&amp; error.cause.code == <span class="hljs-string">'ENOENT'</span>) {</pre></div></div>

        </li>


        <li id="section-35">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p><em>If the file doesn’t exist, use a default configuration.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>                config = { <span class="hljs-attr">size</span>: <span class="hljs-number">5</span> }
            } <span class="hljs-keyword">else</span> {</pre></div></div>

        </li>


        <li id="section-36">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p><em>Otherwise report config file errors.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">throw</span> error
            }
        }

        okay(config, { <span class="hljs-attr">size</span>: <span class="hljs-number">5</span> }, <span class="hljs-string">'used a default configuration (example)'</span>)
    }</pre></div></div>

        </li>


        <li id="section-37">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-38">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>In the example above we had to use a regular expression on the human
readable message to recover from a file I/O error. We cannot use an
equality test because the message contains the file name which is
variable. It is not reassuring to see these fuzzy conditions on the error
path. Someone could break our code by rewording their error message.</p>

            </div>

        </li>


        <li id="section-39">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>One way to add rigorous error type information is to create multiple
error types. This is what they taught you to do when you first learned
about exceptions; create an exception taxonomy.</p>

            </div>

        </li>


        <li id="section-40">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- an Error heirarchy ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises

        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Error</span> </span>{}
        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigIOError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConfigError</span> </span>{}
        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigParseError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConfigError</span> </span>{}
        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigFormatError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConfigError</span> </span>{}
        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigParamError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConfigError</span> </span>{}
        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigMissingParamError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConfigParamError</span> </span>{}
        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigInvalidParamError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConfigParamError</span> </span>{}

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadJSONConfiguration</span> (<span class="hljs-params">filename</span>) </span>{
            <span class="hljs-keyword">let</span> json
            <span class="hljs-keyword">try</span> {
                json = <span class="hljs-keyword">await</span> fs.readFile(filename, <span class="hljs-string">''</span>)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">const</span> e = <span class="hljs-keyword">new</span> ConfigIOError(<span class="hljs-string">'file unreadable: '</span> + filename)
                e.cause = error
                <span class="hljs-keyword">throw</span> e
            }
            <span class="hljs-keyword">let</span> config
            <span class="hljs-keyword">try</span> {
                config = <span class="hljs-built_in">JSON</span>.parse(json)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">const</span> e = <span class="hljs-keyword">new</span> ConfigParseError(<span class="hljs-string">'unable to parse configuration'</span>)
                e.cause = error
                <span class="hljs-keyword">throw</span> e
            }
            <span class="hljs-keyword">if</span> (config == <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> config != <span class="hljs-string">'object'</span> || <span class="hljs-built_in">Array</span>.isArray(object)) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigFormatError(<span class="hljs-string">'JSON must be an object'</span>)
            }
            <span class="hljs-keyword">if</span> (config.size == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigParamMissingError(<span class="hljs-string">'memory is a require configuration parameter'</span>)
            }
            <span class="hljs-keyword">if</span> (config.size == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigParamTypeError(<span class="hljs-string">'memory configuration parameter must be a number'</span>)
            }
            <span class="hljs-keyword">return</span> config
        }

        <span class="hljs-keyword">let</span> config
        <span class="hljs-keyword">try</span> {
            config = <span class="hljs-keyword">await</span> loadJSONConfiguration(path.join(__dirname, <span class="hljs-string">'missing.txt'</span>))
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            <span class="hljs-keyword">if</span> ((error <span class="hljs-keyword">instanceof</span> ConfigIOError) &amp;&amp; error.cause.code == <span class="hljs-string">'ENOENT'</span>) {</pre></div></div>

        </li>


        <li id="section-41">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p><em>If the file doesn’t exist, use a default configuration.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>                config = { <span class="hljs-attr">size</span>: <span class="hljs-number">5</span> }
            } <span class="hljs-keyword">else</span> {</pre></div></div>

        </li>


        <li id="section-42">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p><em>Otherwise report config file errors.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">throw</span> error
            }
        }

        okay(config, { <span class="hljs-attr">size</span>: <span class="hljs-number">5</span> }, <span class="hljs-string">'used a default configuration (example)'</span>)
    }</pre></div></div>

        </li>


        <li id="section-43">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-44">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>Other languages have the ability to catch an exception by type. This
ability to catch by type is where the idea for an exception class for
each type of error comes from.</p>

            </div>

        </li>


        <li id="section-45">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>JavaScript does not have this ability so once the exception is caught it
must be filtered through an <code>if</code>/<code>else</code> ladder with <code>instanceof</code> to
determine the type of exception. Using entire classes for what is
essentially a flag is a heavyweight approach. The user now has to import
the module’s exceptions into the namespace of their application to use
them as test conditions. Not only do we have to add this <code>if</code>/<code>else</code>
ladder, we have to our <code>require</code> statements start to look like this.</p>

            </div>

        </li>


        <li id="section-46">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <pre><code class="language-javascript"><span class="hljs-keyword">const</span> {
    ConfigParseError,
    ConfigIOError,
    loadJSONConfiguration
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./config'</span>)</code></pre>

            </div>

        </li>


        <li id="section-47">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>Kinda feels like we’re moving the internals of a dependency into our
module to check a flag. This is so foreign to JavaScript, to use type
information directly, instead of using ploymorphism.</p>

            </div>

        </li>


        <li id="section-48">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>Node.js itself doesn’t extend the error class heirarchy by much.  In
fact, in our code we further test the cause of the I/O error by checking
a <code>code</code> property to see if it is a <code>ENOENT</code>, the POSIX code for a
missing file.</p>

            </div>

        </li>


        <li id="section-49">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>The Node.js libraries use a base <code>Error</code> class (with the exception of the
<code>assert</code> module) and simply set a <code>code</code> on the error object. All of the
errors eminating from the standard Node.js modules have a <code>code</code> property
and each <code>code</code> property has associated documentation.</p>

            </div>

        </li>


        <li id="section-50">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>If you use codes your module can adhere to this practice.</p>

            </div>

        </li>


        <li id="section-51">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- errors using codes ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadJSONConfiguration</span> (<span class="hljs-params">filename</span>) </span>{
            <span class="hljs-keyword">let</span> json
            <span class="hljs-keyword">try</span> {
                json = <span class="hljs-keyword">await</span> fs.readFile(filename, <span class="hljs-string">''</span>)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">const</span> e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'file unreadable: '</span> + filename)
                e.code = <span class="hljs-string">'IO_ERROR'</span>
                e.cause = error
                <span class="hljs-keyword">throw</span> e
            }
            <span class="hljs-keyword">let</span> config
            <span class="hljs-keyword">try</span> {
                config = <span class="hljs-built_in">JSON</span>.parse(json)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">const</span> e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'unable to parse configuration'</span>)
                e.code = <span class="hljs-string">'PARSE_ERROR'</span>
                <span class="hljs-keyword">throw</span> e
            }
            <span class="hljs-keyword">if</span> (config == <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> config != <span class="hljs-string">'object'</span> || <span class="hljs-built_in">Array</span>.isArray(object)) {
                <span class="hljs-keyword">const</span> e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'JSON must be an object'</span>)
                e.code = <span class="hljs-string">'FORMAT_ERROR'</span>
                <span class="hljs-keyword">throw</span> e
            }
            <span class="hljs-keyword">if</span> (config.size == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">const</span> e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'required parameter missing: memory'</span>)
                e.code = <span class="hljs-string">'CONFIG_PARAM_MISSING'</span>
                <span class="hljs-keyword">throw</span> e
            }
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> config.size == <span class="hljs-string">'number'</span>) {
                <span class="hljs-keyword">const</span> e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'required parameter wrong type: memory'</span>)
                e.code = <span class="hljs-string">'CONFIG_PARAM_INVALID_TYPE'</span>
                <span class="hljs-keyword">throw</span> e
            }
            <span class="hljs-keyword">return</span> config
        }

        <span class="hljs-keyword">let</span> config
        <span class="hljs-keyword">try</span> {
            config = <span class="hljs-keyword">await</span> loadJSONConfiguration(path.join(__dirname, <span class="hljs-string">'missing.txt'</span>))
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            <span class="hljs-keyword">if</span> (error.code == <span class="hljs-string">'IO_ERROR'</span>  &amp;&amp; error.cause.code == <span class="hljs-string">'ENOENT'</span>) {</pre></div></div>

        </li>


        <li id="section-52">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p><em>If the file doesn’t exist, use a default configuration.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>                config = { <span class="hljs-attr">size</span>: <span class="hljs-number">5</span> }
            } <span class="hljs-keyword">else</span> {</pre></div></div>

        </li>


        <li id="section-53">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p><em>Otherwise report config file errors.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">throw</span> error
            }
        }

        okay(config, { <span class="hljs-attr">size</span>: <span class="hljs-number">5</span> }, <span class="hljs-string">'used a default configuration (example)'</span>)
    }</pre></div></div>

        </li>


        <li id="section-54">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-55">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>Interrupt prefers to use codes as well. Interrupt encourages you to
create a set of error codes for your module.</p>

            </div>

        </li>


        <li id="section-56">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>You can still create an Error object heirarchy using Interrupt, but once
you have a set of codes you start to see how they’re easier to work with.</p>

            </div>

        </li>


        <li id="section-57">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>You declare your codes when you create your Interrupt derived class. You
can obtain a list of declared codes using the static <code>codes</code> property.</p>

            </div>

        </li>


        <li id="section-58">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>In the example below we declare a <code>ConfigError</code> class with an object
that maps the error codes to an error message. We can get a list of the
codes defined using the <code>codes</code> property of the generated class.</p>

            </div>

        </li>


        <li id="section-59">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {</pre></div></div>

        </li>


        <li id="section-60">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p><em><code>Interrupt</code> is an <code>Error</code>.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>        okay(Interrupt.prototype <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span>, <span class="hljs-string">'generated error is an `Error`'</span>)</pre></div></div>

        </li>


        <li id="section-61">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p><em>Generate an <code>Interrupt</code> derived error class.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">const</span> ConfigError = Interrupt.create(<span class="hljs-string">'ConfigError'</span>, {
            <span class="hljs-attr">IO_ERROR</span>: <span class="hljs-string">'unable to read config file'</span>,
            <span class="hljs-attr">PARSE_ERROR</span>: <span class="hljs-string">'unable to parse config file'</span>
        })

        <span class="hljs-keyword">const</span> codes = ConfigError.codes
        okay(codes.sort(), [ <span class="hljs-string">'IO_ERROR'</span>, <span class="hljs-string">'PARSE_ERROR'</span> ], <span class="hljs-string">'create error codes'</span>)</pre></div></div>

        </li>


        <li id="section-62">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-63">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p><em>Generated <code>Error</code> class is an <code>Error</code>.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>        okay(ConfigError.prototype <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span>, <span class="hljs-string">'generated error is an `Error`'</span>)</pre></div></div>

        </li>


        <li id="section-64">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p><em>Generated <code>Error</code> class is an <code>Interrupt</code>.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>        okay(ConfigError.prototype <span class="hljs-keyword">instanceof</span> Interrupt, <span class="hljs-string">'generated error is an `Interrupt`'</span>)
    }</pre></div></div>

        </li>


        <li id="section-65">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-66">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>Furthermore, Interrupt discourages the use of the <code>message</code> property
programmatically. In fact, Interrupt hijacks the <code>message</code>, adding
context and nested error stack traces so that they will appear in
<code>error.stack</code>.</p>

            </div>

        </li>


        <li id="section-67">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>Hijacking sounds bad, I know, but jamming all the report information into
the <code>message</code> means it will appear in <code>stack</code>. Becuase it always appears
in <code>stack</code> any facility that dumps <code>stack</code> will get the entire report
without any special knowledge of Interrupt.</p>

            </div>

        </li>


        <li id="section-68">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- message from error code ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> ParseError = Interrupt.create(<span class="hljs-string">'ParseError'</span>, {
            <span class="hljs-attr">INVALID_JSON</span>: <span class="hljs-string">'unable to parse JSON string'</span>,
            <span class="hljs-attr">NULL_ARGUMENT</span>: <span class="hljs-string">'the JSON string to parse must not be null'</span>
        })

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span> (<span class="hljs-params">string</span>) </span>{
            <span class="hljs-keyword">if</span> (string == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ParseError(<span class="hljs-string">'NULL_ARGUMENT'</span>)
            }
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(string)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ParseError(<span class="hljs-string">'INVALID_JSON'</span>)
            }
        }

        <span class="hljs-keyword">try</span> {
            parse(<span class="hljs-literal">null</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.code, <span class="hljs-string">'NULL_ARGUMENT'</span>, <span class="hljs-string">'error code is set'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-69">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-70">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>But, error messages are really for debugging, aren’t they? If we really
wanted a facility to display messages to the user, certianly we’d want
one that supports internationalization. We’d want string tables and we’d
want to solicit translations from open source contributors. We wouldn’t
want all that complexity built into the error path of our application at
every level of the call stack.</p>

            </div>

        </li>


        <li id="section-71">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>Okay, that’s a bit much, but I always dump <code>error.stack</code> and rarely dump
<code>error.message</code>, and we have a way to get just message if that’s all you
need.</p>

            </div>

        </li>


        <li id="section-72">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>If you want to get the plain message for display purposes you can use the
static <code>Interrupt.message()</code> method.</p>

            </div>

        </li>


        <li id="section-73">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- obtain just the message from an Interrupt error ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> invalid_argument = <span class="hljs-string">'the JSON string to parse must not be null'</span>

        <span class="hljs-keyword">const</span> ParseError = Interrupt.create(<span class="hljs-string">'ParseError'</span>, {
            <span class="hljs-attr">INVALID_JSON</span>: <span class="hljs-string">'unable to parse JSON string'</span>,
            <span class="hljs-attr">NULL_ARGUMENT</span>: invalid_argument
        })

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span> (<span class="hljs-params">string</span>) </span>{
            <span class="hljs-keyword">if</span> (string == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ParseError(<span class="hljs-string">'NULL_ARGUMENT'</span>)
            }
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(string)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ParseError(<span class="hljs-string">'INVALID_JSON'</span>)
            }
        }

        <span class="hljs-keyword">try</span> {
            parse(<span class="hljs-literal">null</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${Interrupt.message(error)}</span>\n`</span>)
            okay(<span class="hljs-keyword">new</span> ParseError(<span class="hljs-string">'INVALID_JSON'</span>).message != invalid_argument, <span class="hljs-string">'error message has added context information'</span>)
            okay(Interrupt.message(error), invalid_argument, <span class="hljs-string">'get error message'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-74">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-75">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>The <code>Interrupt.message()</code> method is safe to use with any <code>Error</code>.</p>

            </div>

        </li>


        <li id="section-76">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-keyword">const</span> invalid_argument = <span class="hljs-string">'the JSON string to parse must not be null'</span>

        <span class="hljs-keyword">const</span> ParseError = Interrupt.create(<span class="hljs-string">'ParseError'</span>, {
            <span class="hljs-attr">INVALID_ARGUMENT</span>: invalid_argument
        })

        <span class="hljs-keyword">const</span> interrupt = <span class="hljs-keyword">new</span> ParseError(<span class="hljs-string">'INVALID_ARGUMENT'</span>)

        okay(interrupt.message != invalid_argument, <span class="hljs-string">'message has added context'</span>)
        okay(Interrupt.message(interrupt), invalid_argument, <span class="hljs-string">'get raw plain error message'</span>)

        <span class="hljs-keyword">const</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(invalid_argument)

        okay(error.message, invalid_argument, <span class="hljs-string">'error is as expected'</span>)
        okay(Interrupt.message(error), invalid_argument, <span class="hljs-string">'message getter works with plain `Error`s'</span>)
    }</pre></div></div>

        </li>


        <li id="section-77">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-78">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>You can still test against the <code>message</code> property using a regular
expression. A single line message will appear alone on the first line of
the <code>message</code> property. You can match the entirety of the first line with
a multi-line regular expression.</p>

            </div>

        </li>


        <li id="section-79">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-keyword">const</span> ParseError = Interrupt.create(<span class="hljs-string">'ParseError'</span>, {
            <span class="hljs-attr">INVALID_JSON</span>: <span class="hljs-string">'unable to parse JSON string'</span>,
            <span class="hljs-attr">NULL_ARGUMENT</span>: <span class="hljs-string">'the JSON string to parse must not be null'</span>
        })

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span> (<span class="hljs-params">string</span>) </span>{
            <span class="hljs-keyword">if</span> (string == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ParseError(<span class="hljs-string">'NULL_ARGUMENT'</span>)
            }
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(string)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ParseError(<span class="hljs-string">'INVALID_JSON'</span>)
            }
        }

        <span class="hljs-keyword">try</span> {
            parse(<span class="hljs-literal">null</span>)
        } <span class="hljs-keyword">catch</span> (error) {</pre></div></div>

        </li>


        <li id="section-80">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p><em>Note that the <code>m</code> suffix makes this a multi-line matching regex.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>            okay(<span class="hljs-regexp">/^the JSON string to parse must not be null$/m</span>.test(error.message), <span class="hljs-string">'message is first line of message property'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-81">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-82">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p>If you provide a code parameter that was not defined when you called
<code>Interrupt.create()</code> the string value is used as a message.</p>

            </div>

        </li>


        <li id="section-83">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- create interrupt with missing code ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> ParseError = Interrupt.create(<span class="hljs-string">'ParseError'</span>, {
            <span class="hljs-attr">INVALID_JSON</span>: <span class="hljs-string">'unable to parse JSON string'</span>
        })

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span> (<span class="hljs-params">string</span>) </span>{
            <span class="hljs-keyword">if</span> (string == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ParseError(<span class="hljs-string">'NULL_ARGUMENT'</span>)
            }
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(string)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ParseError(<span class="hljs-string">'INVALID_JSON'</span>)
            }
        }

        <span class="hljs-keyword">try</span> {
            parse(<span class="hljs-literal">null</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(Interrupt.message(error), <span class="hljs-string">'NULL_ARGUMENT'</span>, <span class="hljs-string">'no code found, use first argument as message'</span>)
            okay(!(<span class="hljs-string">'code'</span> <span class="hljs-keyword">in</span> error), <span class="hljs-string">'no code is set'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-84">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-85">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>This means you can just use Interrupt directly without code if you so
choose, but I really like codes.</p>

            </div>

        </li>


        <li id="section-86">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- using Interrupt without codes ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> ParseError = Interrupt.create(<span class="hljs-string">'ParseError'</span>)

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span> (<span class="hljs-params">string</span>) </span>{
            <span class="hljs-keyword">if</span> (string == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ParseError(<span class="hljs-string">'the JSON string to parse must not be null'</span>)
            }
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(string)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ParseError(<span class="hljs-string">'unable to parse JSON string'</span>)
            }
        }

        <span class="hljs-keyword">try</span> {
            parse(<span class="hljs-literal">null</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(Interrupt.message(error), <span class="hljs-string">'the JSON string to parse must not be null'</span>, <span class="hljs-string">'specify message as first argument instead of code'</span>)
            okay(!(<span class="hljs-string">'code'</span> <span class="hljs-keyword">in</span> error), <span class="hljs-string">'no code is set'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-87">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-88">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>You can pass in a code followed by message to override the default
message for the code. This is useful when you use a generic code like
<code>INVALID_ARGUMENT</code> but you want to details about the specific error.</p>

            </div>

        </li>


        <li id="section-89">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises

        <span class="hljs-keyword">const</span> ConfigError = Interrupt.create(<span class="hljs-string">'ConfigError'</span>, {
            <span class="hljs-attr">IO_ERROR</span>: <span class="hljs-string">'unable to read file'</span>,
            <span class="hljs-attr">PARSE_ERROR</span>: <span class="hljs-string">'unable to parse file'</span>
        })

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadConfigs</span> (<span class="hljs-params">dirname</span>) </span>{
            <span class="hljs-keyword">let</span> dir
            <span class="hljs-keyword">try</span> {
                dir = <span class="hljs-keyword">await</span> fs.readdir(dirname)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'IO_ERROR'</span>, <span class="hljs-string">'unable to read dir'</span>)
            }
            <span class="hljs-keyword">const</span> files = []
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> file <span class="hljs-keyword">of</span> dir) {
                <span class="hljs-keyword">let</span> body
                <span class="hljs-keyword">try</span> {
                    body = fs.readFile(path.join(dir, file), <span class="hljs-string">'utf8'</span>)
                } <span class="hljs-keyword">catch</span> (error) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'IO_ERROR'</span>)
                }
                <span class="hljs-keyword">try</span> {
                    configs.push(<span class="hljs-built_in">JSON</span>.parse(body))
                } <span class="hljs-keyword">catch</span> (error) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'PARSE_ERROR'</span>)
                }
            }
        }

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">const</span> dirname = path.join(__dirname, <span class="hljs-string">'tmp'</span>, <span class="hljs-string">'eisdir'</span>)
            <span class="hljs-keyword">await</span> loadConfigs(dirname)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.code, <span class="hljs-string">'IO_ERROR'</span>, <span class="hljs-string">'code set'</span>)
            okay(Interrupt.message(error), <span class="hljs-string">'unable to read file'</span>, <span class="hljs-string">'use default message for code'</span>)
        }

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">const</span> dirname = path.join(__dirname, <span class="hljs-string">'tmp'</span>, <span class="hljs-string">'missing'</span>)
            <span class="hljs-keyword">await</span> loadConfigs(dirname)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`\n<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.code, <span class="hljs-string">'IO_ERROR'</span>, <span class="hljs-string">'code set'</span>)
            okay(Interrupt.message(error), <span class="hljs-string">'unable to read dir'</span>, <span class="hljs-string">'override default message for code'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-90">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-91">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <p>Codes are unambiguous, not liable to change, easier to document and if
you do make changes to code, it is easier to document and document the
deprecation.</p>

            </div>

        </li>


        <li id="section-92">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <p>Codes get even more unambiguous when you use <code>Symbol</code>.</p>

            </div>

        </li>


        <li id="section-93">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <p>Every code you define for your generated Interrupt class will have an
associated <code>Symbol</code>.</p>

            </div>

        </li>


        <li id="section-94">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <p>The generated exception class has a property named for every code you
defined in your call to <code>Interrupt.create()</code>. The property has the code
name and the value is a <code>Symbol</code>. The <code>Symbol</code> is unique for the code.</p>

            </div>

        </li>


        <li id="section-95">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <p>When you create an exception it sets a non-enumerable <code>symbol</code> property
on the exception instance with the associated <code>Symbol</code> for the code as
its value. This is set in addition to the code.</p>

            </div>

        </li>


        <li id="section-96">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <p>The symbol property is not printed in the properties section of the stack
trace message. It is already represented by the <code>code</code> string.</p>

            </div>

        </li>


        <li id="section-97">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <p>Now you can test the exception type by an unambiguous <code>Symbol</code>.</p>

            </div>

        </li>


        <li id="section-98">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- inspecting the code Symbol of an Interrupt ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> ParseError = Interrupt.create(<span class="hljs-string">'ParseError'</span>, {
            <span class="hljs-attr">INVALID_JSON</span>: <span class="hljs-string">'unable to parse JSON string'</span>,
            <span class="hljs-attr">NULL_ARGUMENT</span>: <span class="hljs-string">'the JSON string to parse must not be null'</span>
        })

        okay(<span class="hljs-keyword">typeof</span> ParseError.INVALID_JSON, <span class="hljs-string">'symbol'</span>, <span class="hljs-string">'symbol for INVALID_JSON defined'</span>)

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span> (<span class="hljs-params">string</span>) </span>{
            <span class="hljs-keyword">if</span> (string == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ParseError(<span class="hljs-string">'NULL_ARGUMENT'</span>)
            }
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(json)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ParseError(<span class="hljs-string">'INVALID_JSON'</span>)
            }
        }

        <span class="hljs-keyword">try</span> {
            parse(<span class="hljs-string">'!'</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.symbol === ParseError.INVALID_JSON, <span class="hljs-string">'symbol is set'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-99">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-100">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <p>You can also specify the code by symbol. Instead of passing the string
name of the code you pass in the symbol for the code.</p>

            </div>

        </li>


        <li id="section-101">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- throwing an Interrupt by code Symbol ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> ParseError = Interrupt.create(<span class="hljs-string">'ParseError'</span>, {
            <span class="hljs-attr">INVALID_JSON</span>: <span class="hljs-string">'unable to parse JSON string'</span>,
            <span class="hljs-attr">NULL_ARGUMENT</span>: <span class="hljs-string">'the JSON string to parse must not be null'</span>
        })

        okay(<span class="hljs-keyword">typeof</span> ParseError.INVALID_JSON, <span class="hljs-string">'symbol'</span>, <span class="hljs-string">'symbol for INVALID_JSON defined'</span>)

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span> (<span class="hljs-params">string</span>) </span>{
            <span class="hljs-keyword">if</span> (string == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ParseError(ParseError.NULL_ARGUMENT)
            }
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(json)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ParseError(ParseError.INVALID_JSON)
            }
        }

        <span class="hljs-keyword">try</span> {
            parse(<span class="hljs-string">'!'</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.symbol === ParseError.INVALID_JSON, <span class="hljs-string">'symbol is set'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-102">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-103">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              <p>Because symbols are unique if we use the same code names in two
difference exception classes we can distinguish the type symbol.</p>

            </div>

        </li>


        <li id="section-104">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              <p>You can start to see how symbols and a <code>switch</code> statement can make for a
clean catch block that starts to look like the catch error by type
facility in other languages.</p>

            </div>

        </li>


        <li id="section-105">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-105">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- catching exceptions by type and code ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> CSVError = Interrupt.create(<span class="hljs-string">'ParseError'</span>, {
            <span class="hljs-attr">NULL_ARGUMENT</span>: <span class="hljs-string">'the CSV string to parse must not be null'</span>
        })

        <span class="hljs-keyword">const</span> JSONError = Interrupt.create(<span class="hljs-string">'ParseError'</span>, {
            <span class="hljs-attr">INVALID_JSON</span>: <span class="hljs-string">'unable to parse JSON string'</span>,
            <span class="hljs-attr">NULL_ARGUMENT</span>: <span class="hljs-string">'the JSON string to parse must not be null'</span>
        })

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">csvParse</span> (<span class="hljs-params">csv</span>) </span>{
            <span class="hljs-keyword">if</span> (csv == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CSVError(<span class="hljs-string">'NULL_ARGUMENT'</span>)
            }
            <span class="hljs-keyword">return</span> csv.split(<span class="hljs-regexp">/\s*,\s*/</span>)
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonParse</span> (<span class="hljs-params">json</span>) </span>{
            <span class="hljs-keyword">if</span> (json == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> JSONError(<span class="hljs-string">'NULL_ARGUMENT'</span>)
            }
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(json)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> JSONError(<span class="hljs-string">'INVALID_JSON'</span>)
            }
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span> (<span class="hljs-params">json</span>) </span>{
            <span class="hljs-keyword">let</span> object
            <span class="hljs-keyword">try</span> {
                object = jsonParse(json)
                object.csv = csvParse(object.csv)
                <span class="hljs-keyword">return</span> object
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">switch</span> (error.symbol) {
                <span class="hljs-keyword">case</span> JSONError.NULL_ARGUMENT:
                    <span class="hljs-keyword">return</span> { <span class="hljs-attr">csv</span>: [] }
                <span class="hljs-keyword">case</span> CSVError.NULL_ARGUMENT:
                    object.csv = []
                    <span class="hljs-keyword">return</span> object
                <span class="hljs-keyword">default</span>:
                    <span class="hljs-keyword">throw</span> error
                }
            }
        }

        okay(parse(<span class="hljs-literal">null</span>), { <span class="hljs-attr">csv</span>: [] }, <span class="hljs-string">'convert null to empty object'</span>)
        okay(parse(<span class="hljs-string">'{}'</span>), { <span class="hljs-attr">csv</span>: [] }, <span class="hljs-string">'convert missing CSV to empty array'</span>)
        okay(parse(<span class="hljs-string">'{"csv":"a,b"}'</span>), { <span class="hljs-attr">csv</span>: [ <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span> ] }, <span class="hljs-string">'missing neither JSON nor CSV'</span>)

        <span class="hljs-keyword">try</span> {
            parse(<span class="hljs-string">'!'</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.symbol === JSONError.INVALID_JSON, <span class="hljs-string">'invalid JSON error rethrown'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-106">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-106">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-107">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-107">&#182;</a>
              </div>
              <p>In the contrived example above our CSV parser raises exceptions using a
Symbol to specify the code, the JSON parser uses strings to specify the
code. It doesn’t matter the <code>symbol</code> property is set either way. In our
catch block we use a switch statement to distinguish between a
CSV <code>NULL_ARGUMENT</code> code and a JSON <code>NULL_ARGMENT</code> code.</p>

            </div>

        </li>


        <li id="section-108">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-108">&#182;</a>
              </div>
              <p>Without the <code>symbol</code> property we’d have to compare both the <code>code</code>
property and test the <code>instanceof</code> the <code>error</code> to see if was a <code>CSVError</code>
or a <code>JSONError</code>.</p>

            </div>

        </li>


        <li id="section-109">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-109">&#182;</a>
              </div>
              <p><strong>TODO</strong> We probably need sub-headings.
<strong>TODO</strong> Move this up above symbols.</p>

            </div>

        </li>


        <li id="section-110">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-110">&#182;</a>
              </div>
              <p><strong>TODO</strong> Additional codes.</p>

            </div>

        </li>


        <li id="section-111">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-111">&#182;</a>
              </div>
              <p>They are somewhere else, but you seem to believe they belong here. Maybe
they do, but the code definition function is really only useful when you
want to define additional code properties.</p>

            </div>

        </li>


        <li id="section-112">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-112">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
    }</pre></div></div>

        </li>


        <li id="section-113">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-113">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-114">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-114">&#182;</a>
              </div>
              <h2 id="exception-properties">Exception Properties</h2>

            </div>

        </li>


        <li id="section-115">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-115">&#182;</a>
              </div>
              <p>Ordinarily, setting properties on an error means constructing the error,
then assigning the properties individually before throwing the error.</p>

            </div>

        </li>


        <li id="section-116">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-116">&#182;</a>
              </div>
              <p>Here we set a <code>filename</code> property on an <code>Error</code> before throwing.</p>

            </div>

        </li>


        <li id="section-117">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-117">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- setting properties on an `Error` ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read</span> (<span class="hljs-params">filename</span>) </span>{
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> fs.readFile(filename)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">const</span> e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'unable to read file'</span>)
                e.filename = filename
                <span class="hljs-keyword">throw</span> e
            }
        }

        <span class="hljs-keyword">const</span> filename = path.join(__dirname, <span class="hljs-string">'missing.txt'</span>)

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">await</span> read(filename)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.filename, filename, <span class="hljs-string">'filename property set'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-118">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-118">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-119">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-119">&#182;</a>
              </div>
              <p>With Interrupt you can set properties by specifying an object whose
properties will set on the exception in the constructor. This means you
can throw exceptions with additional properties in a one-liner.</p>

            </div>

        </li>


        <li id="section-120">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-120">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- setting properties with an `Interrupt` constructor ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises

        <span class="hljs-keyword">const</span> ReaderError = Interrupt.create(<span class="hljs-string">'ConfigError'</span>, {
            <span class="hljs-attr">FILE_READ_ERROR</span>: <span class="hljs-string">'unable to read file'</span>
        })</pre></div></div>

        </li>


        <li id="section-121">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-121">&#182;</a>
              </div>
              <p><strong>TODO</strong> Obviously broken. Please fix.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read</span> (<span class="hljs-params">filename</span>) </span>{
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> fs.readdir(dirname)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ReaderError(<span class="hljs-string">'FILE_READ_ERROR'</span>, { filename })
            }
        }

        <span class="hljs-keyword">const</span> filename = path.join(__dirname, <span class="hljs-string">'missing.txt'</span>)

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">await</span> read(filename)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.code, <span class="hljs-string">'FILE_READ_ERROR'</span>, <span class="hljs-string">'code set'</span>)
            okay(error.filename, filename, <span class="hljs-string">'filename property set'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-122">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-122">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-123">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-123">&#182;</a>
              </div>
              <p>Properties primarily be used for reporting. Only codes and other flags
should be acted upon in a catch block.</p>

            </div>

        </li>


        <li id="section-124">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-124">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- the bad practice of using exception properties in application logic ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises

        <span class="hljs-keyword">const</span> ReaderError = Interrupt.create(<span class="hljs-string">'ConfigError'</span>, {
            <span class="hljs-attr">DIRECTORY_MISSING</span>: <span class="hljs-string">'directory cannot be found'</span>,
            <span class="hljs-attr">IO_ERROR</span>: <span class="hljs-string">'unable to read directory'</span>
        })

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read</span> (<span class="hljs-params">dirname</span>) </span>{
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> fs.readdir(dirname)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">if</span> (error.code == <span class="hljs-string">'ENOENT'</span>) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ReaderError(<span class="hljs-string">'DIRECTORY_MISSING'</span>, { dirname })
                }
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ReaderError(<span class="hljs-string">'IO_ERROR'</span>, { dirname })
            }
        }

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readOrCreate</span> (<span class="hljs-params">dirname</span>) </span>{
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> read(dirname)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">if</span> (error.code == <span class="hljs-string">'DIRECTORY_MISSING'</span>) {
                    <span class="hljs-keyword">try</span> {
                        <span class="hljs-keyword">await</span> fs.mkdir(error.dirname, { <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> })
                    } <span class="hljs-keyword">catch</span> (error) {
                        <span class="hljs-built_in">console</span>.log(error.stack)
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ReaderError(<span class="hljs-string">'IO_ERROR'</span>, { <span class="hljs-attr">dirname</span>: error.dirname })
                    }
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> read(error.dirname)
                }
            }
        }

        <span class="hljs-keyword">const</span> dirname = path.join(__dirname, <span class="hljs-string">'tmp'</span>, <span class="hljs-string">'create'</span>, <span class="hljs-string">'one'</span>)

        okay(<span class="hljs-keyword">await</span> readOrCreate(dirname), [], <span class="hljs-string">'created a missing directory'</span>)
    }</pre></div></div>

        </li>


        <li id="section-125">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-125">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-126">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-126">&#182;</a>
              </div>
              <p>There are many reasons why this is bad, but primarily you’ve now treating
your exceptions as if they where a part of your interface. If someone
decides they don’t like having the directory reported, or they decide to
rename the <code>dirame</code> property to <code>directoryName</code> the code will break.</p>

            </div>

        </li>


        <li id="section-127">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-127">&#182;</a>
              </div>
              <p>The exception properties will have to be documented so that users can
depend on then.</p>

            </div>

        </li>


        <li id="section-128">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-128">&#182;</a>
              </div>
              <p>Instead, admonish your users not to use the properties, they are for
reporting only, except for the error code.</p>

            </div>

        </li>


        <li id="section-129">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-129">&#182;</a>
              </div>
              <p>Catch blocks that perform recovery should not be at the root of the call
stack. They should be as close to the source of the error as possible and
they should be able to perform any recovery using the variables visible
within the scope of the catch block.</p>

            </div>

        </li>


        <li id="section-130">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-130">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- use the variables in scope in your catch block instead ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises

        <span class="hljs-keyword">const</span> ReaderError = Interrupt.create(<span class="hljs-string">'ConfigError'</span>, {
            <span class="hljs-attr">DIRECTORY_MISSING</span>: <span class="hljs-string">'directory cannot be found'</span>,
            <span class="hljs-attr">IO_ERROR</span>: <span class="hljs-string">'unable to read directory'</span>
        })

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read</span> (<span class="hljs-params">dirname</span>) </span>{
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> fs.readdir(dirname)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">if</span> (error.code == <span class="hljs-string">'ENOENT'</span>) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ReaderError(<span class="hljs-string">'DIRECTORY_MISSING'</span>, { dirname })
                }
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ReaderError(<span class="hljs-string">'IO_ERROR'</span>, { dirname })
            }
        }

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readOrCreate</span> (<span class="hljs-params">dirname</span>) </span>{
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> read(dirname)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">if</span> (error.code == <span class="hljs-string">'DIRECTORY_MISSING'</span>) {
                    <span class="hljs-keyword">try</span> {
                        <span class="hljs-keyword">await</span> fs.mkdir(dirname, { <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> })
                    } <span class="hljs-keyword">catch</span> (error) {
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ReaderError(<span class="hljs-string">'IO_ERROR'</span>, { dirname })
                    }
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> read(dirname)
                }
            }
        }

        <span class="hljs-keyword">const</span> dirname = path.join(__dirname, <span class="hljs-string">'tmp'</span>, <span class="hljs-string">'create'</span>, <span class="hljs-string">'two'</span>)

        okay(<span class="hljs-keyword">await</span> readOrCreate(dirname), [], <span class="hljs-string">'created a missing directory'</span>)
    }</pre></div></div>

        </li>


        <li id="section-131">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-131">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-132">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-132">&#182;</a>
              </div>
              <p>Now the catch block is only dependent on the error for the error code,
essentially the error type information. It uses the same dirname
variable it used to initial the exceptional function call to recover.</p>

            </div>

        </li>


        <li id="section-133">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-133">&#182;</a>
              </div>
              <p>The exception to this rule is additional error flags that may help a
developer resolve an internal state. We might pass the POSIX error code
onto the user.</p>

            </div>

        </li>


        <li id="section-134">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-134">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- immutable laws of programming are always flexible ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises

        <span class="hljs-keyword">const</span> ReaderError = Interrupt.create(<span class="hljs-string">'ConfigError'</span>, {
            <span class="hljs-attr">IO_ERROR</span>: <span class="hljs-string">'unable to read directory'</span>
        })

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read</span> (<span class="hljs-params">dirname</span>) </span>{
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> fs.readdir(dirname)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ReaderError(<span class="hljs-string">'IO_ERROR'</span>, { dirname, <span class="hljs-attr">posixCode</span>: error.code  })
            }
        }

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readOrCreate</span> (<span class="hljs-params">dirname</span>) </span>{
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> read(dirname)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">if</span> (error.code == <span class="hljs-string">'IO_ERROR'</span> &amp;&amp; error.posixCode == <span class="hljs-string">'ENOENT'</span>) {
                    <span class="hljs-keyword">try</span> {
                        <span class="hljs-keyword">await</span> fs.mkdir(error.dirname, { <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> })
                    } <span class="hljs-keyword">catch</span> (error) {
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ReaderError(<span class="hljs-string">'IO_ERROR'</span>, { dirname, <span class="hljs-attr">posixCode</span>: error.code })
                    }
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> read(error.dirname)
                }
            }
        }

        <span class="hljs-keyword">const</span> dirname = path.join(__dirname, <span class="hljs-string">'tmp'</span>, <span class="hljs-string">'create'</span>, <span class="hljs-string">'three'</span>)

        okay(<span class="hljs-keyword">await</span> readOrCreate(dirname), [], <span class="hljs-string">'created a missing directory'</span>)
    }</pre></div></div>

        </li>


        <li id="section-135">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-135">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-136">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-136">&#182;</a>
              </div>
              <p>Actually, how about we don’t make a rule? Let’s call this an opinion. I
just don’t want you, dear reader, to mistakenly think that Interrupt is
encouraging you migrate your application code into the catch blocks.
Interrupt is all about reporting. Exceptions are tricky on a good day.
The error path is fraught with peril. Try to keep your application logic
out of it if you can.</p>

            </div>

        </li>


        <li id="section-137">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-137">&#182;</a>
              </div>
              <p>In addition to setting properties at construction, you can assign default
properties by code.</p>

            </div>

        </li>


        <li id="section-138">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-138">&#182;</a>
              </div>
              <p>When defining a code using <code>Interrupt.create()</code>, a format message for the
value of code map, you use an object. The properties of that object will
be set on the exception when it is created with the code. The <code>message</code>
property of the object will be used as the exception message.</p>

            </div>

        </li>


        <li id="section-139">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-139">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises

        <span class="hljs-keyword">const</span> ConfigError = Interrupt.create(<span class="hljs-string">'ConfigError'</span>, {
            <span class="hljs-attr">CONFIG_IO_ERROR</span>: {
                <span class="hljs-attr">fallback</span>: <span class="hljs-literal">true</span>,
                <span class="hljs-attr">message</span>: <span class="hljs-string">'unable to read file'</span>
            },
            <span class="hljs-attr">CONFIG_PARSE_ERROR</span>: {
                <span class="hljs-attr">message</span>: <span class="hljs-string">'unable to parse JSON'</span>
            }
        })

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span> (<span class="hljs-params">filename</span>) </span>{
            <span class="hljs-keyword">let</span> json
            <span class="hljs-keyword">try</span> {
                json = <span class="hljs-keyword">await</span> fs.readFile(filename, <span class="hljs-string">'utf8'</span>)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'CONFIG_IO_ERROR'</span>, { filename })
            }
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(json)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'CONFIG_PARSE_ERROR'</span>, { filename })
            }
        }

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadOrFallback</span> (<span class="hljs-params">filename</span>) </span>{
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> load(filename)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">if</span> (error.fallback) {
                    <span class="hljs-keyword">return</span> {}
                }
                <span class="hljs-keyword">throw</span> error
            }
        }

        <span class="hljs-keyword">const</span> filename = path.join(__dirname, <span class="hljs-string">'tmp'</span>, <span class="hljs-string">'missing'</span>)

        okay(<span class="hljs-keyword">await</span> loadOrFallback(filename), {}, <span class="hljs-string">'caught using a default property'</span>)

        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- catch an error with a default property ---\n'</span>)
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">await</span> load(filename)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.code, <span class="hljs-string">'CONFIG_IO_ERROR'</span>, <span class="hljs-string">'default property code set'</span>)
            okay(error.fallback, <span class="hljs-string">'default property set'</span>)
        }

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">await</span> load(path.join(__dirname, <span class="hljs-string">'tmp'</span>, <span class="hljs-string">'bad'</span>, <span class="hljs-string">'config.json'</span>))
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`\n<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.code, <span class="hljs-string">'CONFIG_PARSE_ERROR'</span>, <span class="hljs-string">'no default property code set'</span>)
            okay(!error.fallback, <span class="hljs-string">'no default property property not set'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-140">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-140">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-141">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-141">&#182;</a>
              </div>
              <p>Once you’ve started to use codes you may find that one code per error is
not enough. You may want to have additional codes to classify errors.</p>

            </div>

        </li>


        <li id="section-142">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-142">&#182;</a>
              </div>
              <p>You can define additional codes with no message or properties by
specifying them as strings in the call to <code>Interrupt.create()</code>.</p>

            </div>

        </li>


        <li id="section-143">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-143">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- define additional message-less error codes string by string ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)

        <span class="hljs-keyword">const</span> ConfigError = Interrupt.create(<span class="hljs-string">'ConfigError'</span>, {
            <span class="hljs-string">'READ_FILE_ERROR'</span>: <span class="hljs-string">'unable to read file'</span>,
            <span class="hljs-string">'PARSE_ERROR'</span>: <span class="hljs-string">'unable to parse JSON'</span>
        }, <span class="hljs-string">'SUBSYSTEM_IO'</span>, <span class="hljs-string">'SUBSYSTEM_CONFIG'</span>)

        okay(<span class="hljs-keyword">typeof</span> ConfigError.SUBSYSTEM_CONFIG, <span class="hljs-string">'symbol'</span>, <span class="hljs-string">'additional code created'</span>)

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span> (<span class="hljs-params">filename</span>) </span>{
            <span class="hljs-keyword">let</span> json
            <span class="hljs-keyword">try</span> {
                json = <span class="hljs-keyword">await</span> fs.readFile(filename, <span class="hljs-string">'utf8'</span>)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'CONFIG_IO_ERROR'</span>, { filename, <span class="hljs-attr">subsystem</span>: ConfigError.SUBSYSTEM_IO })
            }
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(json)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'CONFIG_PARSE_ERROR'</span>, { filename, <span class="hljs-attr">subsystem</span>: ConfigError.SUBSYSTEM_CONFIG  })
            }
        }

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">await</span> load(path.join(__dirname, <span class="hljs-string">'tmp'</span>, <span class="hljs-string">'missing.json'</span>))
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.subsystem, ConfigError.SUBSYSTEM_IO, <span class="hljs-string">'additional symbol code property set'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-144">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-144">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-145">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-145">&#182;</a>
              </div>
              <p>These additional codes can also be specified as an array.</p>

            </div>

        </li>


        <li id="section-146">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-146">&#182;</a>
              </div>
              <p>Once you’ve started to use codes you may find that one code per error is
not enough. You may want to have additional codes to classify errors.</p>

            </div>

        </li>


        <li id="section-147">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-147">&#182;</a>
              </div>
              <p>You can define additional codes with no message or properties by
specifying them as strings in the call to <code>Interrupt.create()</code>.</p>

            </div>

        </li>


        <li id="section-148">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-148">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- define additional message-less error codes string by string ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)

        <span class="hljs-keyword">const</span> ConfigError = Interrupt.create(<span class="hljs-string">'ConfigError'</span>, {
            <span class="hljs-string">'READ_FILE_ERROR'</span>: <span class="hljs-string">'unable to read file'</span>,
            <span class="hljs-string">'PARSE_ERROR'</span>: <span class="hljs-string">'unable to parse JSON'</span>
        }, <span class="hljs-string">'SUBSYSTEM_IO'</span>, <span class="hljs-string">'SUBSYSTEM_CONFIG'</span>)

        okay(<span class="hljs-keyword">typeof</span> ConfigError.SUBSYSTEM_CONFIG, <span class="hljs-string">'symbol'</span>, <span class="hljs-string">'additional code created'</span>)

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span> (<span class="hljs-params">filename</span>) </span>{
            <span class="hljs-keyword">let</span> json
            <span class="hljs-keyword">try</span> {
                json = <span class="hljs-keyword">await</span> fs.readFile(filename, <span class="hljs-string">'utf8'</span>)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'CONFIG_IO_ERROR'</span>, { filename, <span class="hljs-attr">subsystem</span>: ConfigError.SUBSYSTEM_IO })
            }
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(json)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'CONFIG_PARSE_ERROR'</span>, { filename, <span class="hljs-attr">subsystem</span>: ConfigError.SUBSYSTEM_CONFIG  })
            }
        }

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">await</span> load(path.join(__dirname, <span class="hljs-string">'tmp'</span>, <span class="hljs-string">'missing.json'</span>))
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`\n<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.subsystem, ConfigError.SUBSYSTEM_IO, <span class="hljs-string">'additional symbol code property set'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-149">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-149">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-150">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-150">&#182;</a>
              </div>
              <p>You can also define additional codes as an array of strings. Instead of
passing in a straight up array, though, I like to split a string so that
maintaining the list is easier.</p>

            </div>

        </li>


        <li id="section-151">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-151">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- define additional message-less error codes string by string ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)

        <span class="hljs-keyword">const</span> ConfigError = Interrupt.create(<span class="hljs-string">'ConfigError'</span>, {
            <span class="hljs-string">'READ_FILE_ERROR'</span>: <span class="hljs-string">'unable to read file'</span>,
            <span class="hljs-string">'PARSE_ERROR'</span>: <span class="hljs-string">'unable to parse JSON'</span>
        }, <span class="hljs-string">`
            SUBSYSTEM_IO
            SUBSYSTEM_CONFIG
        `</span>.trim().split(<span class="hljs-regexp">/\s\s*/g</span>))

        okay(<span class="hljs-keyword">typeof</span> ConfigError.SUBSYSTEM_CONFIG, <span class="hljs-string">'symbol'</span>, <span class="hljs-string">'additional code created'</span>)

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span> (<span class="hljs-params">filename</span>) </span>{
            <span class="hljs-keyword">let</span> json
            <span class="hljs-keyword">try</span> {
                json = <span class="hljs-keyword">await</span> fs.readFile(filename, <span class="hljs-string">'utf8'</span>)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'READ_FILE_ERROR'</span>, { filename, <span class="hljs-attr">subsystem</span>: ConfigError.SUBSYSTEM_IO })
            }
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(json)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'PARSE_ERROR'</span>, { filename, <span class="hljs-attr">subsystem</span>: ConfigError.SUBSYSTEM_CONFIG  })
            }
        }

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">await</span> load(path.join(__dirname, <span class="hljs-string">'tmp'</span>, <span class="hljs-string">'missing.json'</span>))
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`\n<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.subsystem, ConfigError.SUBSYSTEM_IO, <span class="hljs-string">'additional symbol code property set'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-152">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-152">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-153">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-153">&#182;</a>
              </div>
              <p>Lastly you can define codes using a function. The function must return
either a code object map, a code array, a code string or anther code
function. The function will receive as its only argument of map of code
name strings to the code symbols for the codes defined by any previous
code declarations in the parameter list.</p>

            </div>

        </li>


        <li id="section-154">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-154">&#182;</a>
              </div>
              <p>With this we are able to define a default property with a code symbol
value using codes we’ve defined in the constructor.</p>

            </div>

        </li>


        <li id="section-155">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-155">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- define additional message-less error codes string by string ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)

        <span class="hljs-keyword">const</span> ConfigError = Interrupt.create(<span class="hljs-string">'ConfigError'</span>, [
            <span class="hljs-string">'SUBSYSTEM_IO'</span>, <span class="hljs-string">'SUBSYSTEM_CONFIG'</span>
        ], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">{ Codes }</span>) </span>{
            <span class="hljs-keyword">return</span> {
                <span class="hljs-string">'READ_FILE_ERROR'</span>: {
                    <span class="hljs-attr">message</span>: <span class="hljs-string">'unable to read file'</span>,
                    <span class="hljs-attr">subsystem</span>: Codes[<span class="hljs-string">'SUBSYSTEM_IO'</span>].symbol
                },
                <span class="hljs-string">'PARSE_ERROR'</span>: {
                    <span class="hljs-attr">message</span>: <span class="hljs-string">'unable to parse JSON'</span>,
                    <span class="hljs-attr">subsystem</span>: Codes[<span class="hljs-string">'SUBSYSTEM_CONFIG'</span>].symbol
                }
            }
        })

        okay(<span class="hljs-keyword">typeof</span> ConfigError.SUBSYSTEM_CONFIG, <span class="hljs-string">'symbol'</span>, <span class="hljs-string">'additional code created'</span>)

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span> (<span class="hljs-params">filename</span>) </span>{
            <span class="hljs-keyword">let</span> json
            <span class="hljs-keyword">try</span> {
                json = <span class="hljs-keyword">await</span> fs.readFile(filename, <span class="hljs-string">'utf8'</span>)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'READ_FILE_ERROR'</span>, { filename })
            }
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(json)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'PARSE_ERROR'</span>, { filename })
            }
        }

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">await</span> load(path.join(__dirname, <span class="hljs-string">'tmp'</span>, <span class="hljs-string">'missing.json'</span>))
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`\n<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.subsystem, ConfigError.SUBSYSTEM_IO, <span class="hljs-string">'additional symbol code property set'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-156">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-156">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-157">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-157">&#182;</a>
              </div>
              <p>An interesting property of the codes map given to a code function is that
the <code>code</code> property is enumerable and the <code>symbol</code> property is not.</p>
<p><strong>TODO</strong> Would I use this and why dishearten the user with this sort of
thing? Simply suggest that they use a single symbol. I suppose it was for
the sake of output. Perhaps a <code>toJSON</code> method?</p>
<p>Can’t find a way. The only thing that bothers me about this is that
you’ll display a symbol in the stack trace instead of a string and it
won’t turn back into a string when you parse. Seems dubious. This is
such a triviality, I shouldn’t make such a big deal of it.</p>
<p>Not sure that naming it <code>&#39;string&#39;</code> is such a great idea. Using a
<code>toJSON()</code> changes the shape of the object.</p>
<p><strong>TODO</strong> Okay, this is now the silliest bit. Don’t overthink it.</p>
<p>Because Interrupt uses JSON to serialize properties, and because JSON
will only serialize enumerable properties, this means that if you use
this object as the value of a default property, the code will be
serialized in the stack trace, but the symbol will not.</p>

            </div>

        </li>


        <li id="section-158">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-158">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)

        <span class="hljs-keyword">const</span> ConfigError = Interrupt.create(<span class="hljs-string">'ConfigError'</span>, [
            <span class="hljs-string">'SUBSYSTEM_IO'</span>, <span class="hljs-string">'SUBSYSTEM_CONFIG'</span>
        ], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">{ Codes }</span>) </span>{
            <span class="hljs-keyword">return</span> {
                <span class="hljs-string">'READ_FILE_ERROR'</span>: {
                    <span class="hljs-attr">message</span>: <span class="hljs-string">'unable to read file'</span>,
                    <span class="hljs-attr">subsystem</span>: Interrupt.Code(Codes[<span class="hljs-string">'SUBSYSTEM_IO'</span>])
                },
                <span class="hljs-string">'PARSE_ERROR'</span>: {
                    <span class="hljs-attr">message</span>: <span class="hljs-string">'unable to parse JSON'</span>,
                    <span class="hljs-attr">subsystem</span>: Interrupt.Code(Codes[<span class="hljs-string">'SUBSYSTEM_CONFIG'</span>])
                }
            }
        })

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span> (<span class="hljs-params">filename</span>) </span>{
            <span class="hljs-keyword">let</span> json
            <span class="hljs-keyword">try</span> {
                json = <span class="hljs-keyword">await</span> fs.readFile(filename, <span class="hljs-string">'utf8'</span>)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'READ_FILE_ERROR'</span>, { filename })
            }
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(json)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'PARSE_ERROR'</span>, { filename })
            }
        }
        <span class="hljs-keyword">const</span> error = <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'READ_FILE_ERROR'</span>)

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">await</span> load(path.join(__dirname, <span class="hljs-string">'tmp'</span>, <span class="hljs-string">'missing.json'</span>))
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`\n<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.subsystem.code, <span class="hljs-string">'SUBSYSTEM_IO'</span>, <span class="hljs-string">'additional code property set'</span>)
            okay(error.subsystem.symbol, ConfigError.SUBSYSTEM_IO, <span class="hljs-string">'additional symbol code property set'</span>)
            okay(<span class="hljs-built_in">JSON</span>.stringify(error.subsystem), <span class="hljs-string">'{"code":"SUBSYSTEM_IO"}'</span>, <span class="hljs-string">'only code is serialized'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-159">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-159">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-160">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-160">&#182;</a>
              </div>
              <p>This esoteric behavior is there for you to abuse in your own programs.
The end user might notice that the symbol goes missing if they JSON
serialize the value themselves, but such are the mysteries of exception
handling with its many non-enumerable properties.</p>

            </div>

        </li>


        <li id="section-161">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-161">&#182;</a>
              </div>
              <p>If you’ve made it this far, you may have noticed that we tend to use
<code>switch</code> statements with codes in our catch blocks. This is nice because
it starts to look like the sort of catch by type facility you see in
other languages. However, it is not type safe the way that it is in other
languages.</p>

            </div>

        </li>


        <li id="section-162">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-162">&#182;</a>
              </div>
              <p>The code below will fall back to a default configuration if it has any
trouble reading from the filesystem, but if it gets a back configuration
it will rethrow the error.</p>

            </div>

        </li>


        <li id="section-163">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-163">&#182;</a>
              </div>
              <p>It has a subtle bug that is on the error path.</p>

            </div>

        </li>


        <li id="section-164">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-164">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises

        <span class="hljs-keyword">const</span> ConfigError = Interrupt.create(<span class="hljs-string">'ConfigError'</span>, {
            <span class="hljs-attr">DIRECTORY_READ_ERROR</span>: <span class="hljs-string">'unable to read directory'</span>,
            <span class="hljs-attr">FILE_READ_ERROR</span>: <span class="hljs-string">'unable to read file'</span>
        })

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadConfigs</span> (<span class="hljs-params">dirname</span>) </span>{
            <span class="hljs-keyword">let</span> dir
            <span class="hljs-keyword">try</span> {
                dir = <span class="hljs-keyword">await</span> fs.readdir(dirname)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'DIRECTORY_READ_ERROR'</span>, <span class="hljs-string">'unable to read dir'</span>, { dirname })
            }
            <span class="hljs-keyword">const</span> configs = []
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> file <span class="hljs-keyword">of</span> dir) {
                <span class="hljs-keyword">const</span> filename = path.join(dirname, file)
                <span class="hljs-keyword">let</span> body
                <span class="hljs-keyword">try</span> {
                    body = <span class="hljs-keyword">await</span> fs.readFile(filename, <span class="hljs-string">'utf8'</span>)
                } <span class="hljs-keyword">catch</span> (error) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'FILE_READ_ERROR'</span>, { filename })
                }
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-built_in">console</span>.log(body)
                    configs.push(<span class="hljs-built_in">JSON</span>.parse(body))
                } <span class="hljs-keyword">catch</span> (error) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'FILE_PARSE_ERROR'</span>)
                }
            }
            <span class="hljs-keyword">return</span> configs
        }

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadConfigsFallback</span> (<span class="hljs-params">dirname</span>) </span>{
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> loadConfigs(dirname)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">switch</span> (error.symbol) {</pre></div></div>

        </li>


        <li id="section-165">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-165">&#182;</a>
              </div>
              <p><em>Spelling error.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">case</span> ConfigError.DIRECTROY_READ_ERROR:
                <span class="hljs-keyword">case</span> ConfigError.FILE_READ_ERROR:
                    <span class="hljs-keyword">return</span> [{ <span class="hljs-attr">settings</span>: { <span class="hljs-attr">volume</span>: <span class="hljs-number">0</span> } }]
                <span class="hljs-keyword">default</span>:
                    <span class="hljs-keyword">throw</span> error
                }
            }
        }</pre></div></div>

        </li>


        <li id="section-166">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-166">&#182;</a>
              </div>
              <p><em>We expect a missing directory to result in a default but…</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">await</span> loadConfigsFallback(path.join(__dirname, <span class="hljs-string">'tmp'</span>, <span class="hljs-string">'missing'</span>))
        } <span class="hljs-keyword">catch</span> (error) {</pre></div></div>

        </li>


        <li id="section-167">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-167">&#182;</a>
              </div>
              <p><em>… the error was rethrown.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.code, <span class="hljs-string">'DIRECTORY_READ_ERROR'</span>, <span class="hljs-string">'we didn\'t want this to be thrown'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-168">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-168">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-169">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-169">&#182;</a>
              </div>
              <p>The same code object with a string <code>code</code> property an a non-enumerable
<code>symbol</code> property is returned from the static <code>codes()</code> function in the
generated <code>Interrupt</code> class.</p>

            </div>

        </li>


        <li id="section-170">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-170">&#182;</a>
              </div>
              <p>If we use this object in our switch statements, we only need to unit test
one case out of a set of cases to know that all the cases in the switch
statement are defined.</p>

            </div>

        </li>


        <li id="section-171">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-171">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises

        <span class="hljs-keyword">const</span> ConfigError = Interrupt.create(<span class="hljs-string">'ConfigError'</span>, {
            <span class="hljs-attr">DIRECTORY_READ_ERROR</span>: <span class="hljs-string">'unable to read directory'</span>,
            <span class="hljs-attr">FILE_READ_ERROR</span>: <span class="hljs-string">'unable to read file'</span>
        })

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadConfigs</span> (<span class="hljs-params">dirname</span>) </span>{
            <span class="hljs-keyword">let</span> dir
            <span class="hljs-keyword">try</span> {
                dir = <span class="hljs-keyword">await</span> fs.readdir(dirname)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'DIRECTORY_READ_ERROR'</span>, <span class="hljs-string">'unable to read dir'</span>, { dirname })
            }
            <span class="hljs-keyword">const</span> configs = []
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> file <span class="hljs-keyword">of</span> dir) {
                <span class="hljs-keyword">const</span> filename = path.join(dirname, file)
                <span class="hljs-keyword">let</span> body
                <span class="hljs-keyword">try</span> {
                    body = <span class="hljs-keyword">await</span> fs.readFile(filename, <span class="hljs-string">'utf8'</span>)
                } <span class="hljs-keyword">catch</span> (error) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'FILE_READ_ERROR'</span>, { filename })
                }
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-built_in">console</span>.log(body)
                    configs.push(<span class="hljs-built_in">JSON</span>.parse(body))
                } <span class="hljs-keyword">catch</span> (error) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'FILE_PARSE_ERROR'</span>)
                }
            }
            <span class="hljs-keyword">return</span> configs
        }

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadConfigsFallback</span> (<span class="hljs-params">dirname</span>) </span>{
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> loadConfigs(dirname)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">switch</span> (error.symbol) {</pre></div></div>

        </li>


        <li id="section-172">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-172">&#182;</a>
              </div>
              <p><em>Spelling error.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">case</span> ConfigError.code(<span class="hljs-string">'DIRECTROY_READ_ERROR'</span>).symbol:
                <span class="hljs-keyword">case</span> ConfigError.code(<span class="hljs-string">'FILE_READ_ERROR'</span>).symbol:
                    <span class="hljs-keyword">return</span> [{ <span class="hljs-attr">settings</span>: { <span class="hljs-attr">volume</span>: <span class="hljs-number">0</span> } }]
                <span class="hljs-keyword">default</span>:
                    <span class="hljs-keyword">throw</span> error
                }
            }
        }</pre></div></div>

        </li>


        <li id="section-173">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-173">&#182;</a>
              </div>
              <p><em>We expect a missing directory to result in a default but…</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">await</span> loadConfigsFallback(path.join(__dirname, <span class="hljs-string">'tmp'</span>, <span class="hljs-string">'missing'</span>))
        } <span class="hljs-keyword">catch</span> (error) {</pre></div></div>

        </li>


        <li id="section-174">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-174">&#182;</a>
              </div>
              <p><em>… we got a meaningful JavaScript <code>TypeError</code> instead.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">TypeError</span>, <span class="hljs-string">'useful error diagnosing problems with switch statement'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-175">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-175">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-176">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-176">&#182;</a>
              </div>
              <p>It’s more verbose but it allows us to use large sets of codes in switch
statements without having to write a unit test for every conceivable
error to ensure that the error codes are correct. We only need to unit
test the last case before the logic. It also allows us to rename an error
code and catch any overlooked renames.</p>

            </div>

        </li>


        <li id="section-177">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-177">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises

        <span class="hljs-keyword">const</span> ConfigError = Interrupt.create(<span class="hljs-string">'ConfigError'</span>, {
            <span class="hljs-attr">DIRECTORY_READ_ERROR</span>: <span class="hljs-string">'unable to read directory'</span>,
            <span class="hljs-attr">FILE_READ_ERROR</span>: <span class="hljs-string">'unable to read file'</span>
        })

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadConfigs</span> (<span class="hljs-params">dirname</span>) </span>{
            <span class="hljs-keyword">let</span> dir
            <span class="hljs-keyword">try</span> {
                dir = <span class="hljs-keyword">await</span> fs.readdir(dirname)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'DIRECTORY_READ_ERROR'</span>, <span class="hljs-string">'unable to read dir'</span>, { dirname })
            }
            <span class="hljs-keyword">const</span> configs = []
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> file <span class="hljs-keyword">of</span> dir) {
                <span class="hljs-keyword">const</span> filename = path.join(dirname, file)
                <span class="hljs-keyword">let</span> body
                <span class="hljs-keyword">try</span> {
                    body = <span class="hljs-keyword">await</span> fs.readFile(filename, <span class="hljs-string">'utf8'</span>)
                } <span class="hljs-keyword">catch</span> (error) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'FILE_READ_ERROR'</span>, { filename })
                }
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-built_in">console</span>.log(body)
                    configs.push(<span class="hljs-built_in">JSON</span>.parse(body))
                } <span class="hljs-keyword">catch</span> (error) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'FILE_PARSE_ERROR'</span>)
                }
            }
            <span class="hljs-keyword">return</span> configs
        }

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadConfigsFallback</span> (<span class="hljs-params">dirname</span>) </span>{
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> loadConfigs(dirname)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">switch</span> (error.symbol) {</pre></div></div>

        </li>


        <li id="section-178">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-178">&#182;</a>
              </div>
              <p><em>Spelling error fixed.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">case</span> ConfigError.code(<span class="hljs-string">'DIRECTORY_READ_ERROR'</span>).symbol:
                <span class="hljs-keyword">case</span> ConfigError.code(<span class="hljs-string">'FILE_READ_ERROR'</span>).symbol:
                    <span class="hljs-keyword">return</span> [{ <span class="hljs-attr">settings</span>: { <span class="hljs-attr">volume</span>: <span class="hljs-number">0</span> } }]
                <span class="hljs-keyword">default</span>:
                    <span class="hljs-keyword">throw</span> error
                }
            }
        }

        okay(<span class="hljs-keyword">await</span> loadConfigsFallback(path.join(__dirname, <span class="hljs-string">'tmp'</span>, <span class="hljs-string">'missing'</span>)), [{
            <span class="hljs-attr">settings</span>: { <span class="hljs-attr">volume</span>: <span class="hljs-number">0</span> }
        }], <span class="hljs-string">'finally working correctly'</span>)
    }</pre></div></div>

        </li>


        <li id="section-179">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-179">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-180">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-180">&#182;</a>
              </div>
              <p>The enumerability of the properties of your property object will be
applied to the properties when then are set on the constructed exception.</p>

            </div>

        </li>


        <li id="section-181">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-181">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- defining non-enumerable properties in the constructor ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises

        <span class="hljs-keyword">const</span> ConfigError = Interrupt.create(<span class="hljs-string">'ConfigError'</span>, {
            <span class="hljs-string">'FILE_READ_ERROR'</span>: <span class="hljs-string">'unable to read file'</span>,
            <span class="hljs-string">'PARSE_ERROR'</span>: <span class="hljs-string">'unable to parse JSON'</span>
        })

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span> (<span class="hljs-params">filename</span>) </span>{
            <span class="hljs-keyword">let</span> json
            <span class="hljs-keyword">try</span> {
                json = <span class="hljs-keyword">await</span> fs.readFile(filename, <span class="hljs-string">'utf8'</span>)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'FILE_READ_ERROR'</span>, { filename })
            }
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(json)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'PARSE_ERROR'</span>, <span class="hljs-built_in">Object</span>.defineProperties({}, {
                    <span class="hljs-attr">filename</span>: {
                        <span class="hljs-attr">value</span>: filename,
                        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>
                    },
                    <span class="hljs-attr">json</span>: {
                        <span class="hljs-attr">value</span>: json,
                        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>
                    }
                }))
            }
        }

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">await</span> load(__filename)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(<span class="hljs-built_in">Object</span>.keys(error).sort(), [ <span class="hljs-string">'code'</span>, <span class="hljs-string">'filename'</span> ], <span class="hljs-string">'only two enumerable properties'</span>)
            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getOwnPropertyNames(error))
            okay(error.hasOwnProperty(<span class="hljs-string">'json'</span>), <span class="hljs-string">'added a non-enumerable properties'</span>)
            okay(error.json.length &gt; <span class="hljs-number">4096</span>, <span class="hljs-string">'really too big to add to the stack trace'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-182">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-182">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-183">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-183">&#182;</a>
              </div>
              <p>Non enumerable properties will not appear in the stack trace, JSON
serialization and many utilties that print errors will skip those
properties. You can use non-enumerable properties when you want to
provide context information that may need specialized reporting, that
would look rediculous in the stack trace.</p>

            </div>

        </li>


        <li id="section-184">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-184">&#182;</a>
              </div>
              <p>Note that when you use <code>Object.defineProperties</code> you must set the
<code>enumerable</code> property to <code>true</code> for the property to be enumerable. The
default is <code>false</code>. <strong>TODO</strong> Double check. (Internet is down now.)</p>

            </div>

        </li>


        <li id="section-185">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-185">&#182;</a>
              </div>
              <p>You can also specify non-enumerable properties in the default properties
for a code with <code>Interrupt.create()</code>.</p>

            </div>

        </li>


        <li id="section-186">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-186">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- defining non-enumerable default properties at create ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> ConfigError = Interrupt.create(<span class="hljs-string">'ConfigError'</span>, {
            <span class="hljs-attr">NULL_ARGUMENT</span>: <span class="hljs-built_in">Object</span>.defineProperties({}, {</pre></div></div>

        </li>


        <li id="section-187">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-187">&#182;</a>
              </div>
              <p><em>We ask that <code>message</code> be made enumerable, but our request
will be ignored.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>                message: {
                    <span class="hljs-attr">value</span>: <span class="hljs-string">'the JSON string to parse must not be null'</span>,
                    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>
                },
                <span class="hljs-attr">fallback</span>: {
                    <span class="hljs-attr">value</span>: <span class="hljs-literal">false</span>,
                    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>
                }
            }),
            <span class="hljs-attr">INVALID_JSON</span>: <span class="hljs-built_in">Object</span>.defineProperties({}, {
                <span class="hljs-attr">message</span>: {
                    <span class="hljs-attr">value</span>: <span class="hljs-string">'the argument must not be null'</span>,
                    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>
                },
                <span class="hljs-attr">fallback</span>: {
                    <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span>,
                    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>
                }
            })
        })

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span> (<span class="hljs-params">json</span>) </span>{
            <span class="hljs-keyword">if</span> (json == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'NULL_ARGUMENT'</span>)
            }
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(json)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'INVALID_JSON'</span>)
            }
        }

        <span class="hljs-keyword">try</span> {
            parse(<span class="hljs-literal">null</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(<span class="hljs-built_in">Object</span>.keys(error), [ <span class="hljs-string">'code'</span> ], <span class="hljs-string">'only code property set'</span>)
            okay(!error.propertyIsEnumerable(<span class="hljs-string">'message'</span>), <span class="hljs-string">'despite our requests, message is not enumerable'</span>)
            okay(error.fallback, <span class="hljs-literal">false</span>, <span class="hljs-string">'non-enumerable default property set'</span>)
        }

        <span class="hljs-keyword">try</span> {
            parse(<span class="hljs-string">'!'</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(<span class="hljs-built_in">Object</span>.keys(error), [ <span class="hljs-string">'code'</span> ], <span class="hljs-string">'only code property set'</span>)
            okay(error.fallback, <span class="hljs-literal">true</span>, <span class="hljs-string">'non-enumerable default property set'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-188">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-188">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-189">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-189">&#182;</a>
              </div>
              <p>In this example we do not enumerable the <code>fallback</code> property. It is just
a handling hint so we don’t want to see it in our stack trace.</p>

            </div>

        </li>


        <li id="section-190">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-190">&#182;</a>
              </div>
              <p>The <code>message</code>, <code>errors</code>, and <code>symbol</code> properties will never be enumerable
on the created exception regardless of whether or not they are specified
as enumerable in the constructor or defaults.</p>

            </div>

        </li>


        <li id="section-191">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-191">&#182;</a>
              </div>
              <p>The <code>code</code> property will always be enumerable regardless of whether or
not the property is enumerable in the constructor or defaults.</p>

            </div>

        </li>


        <li id="section-192">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-192">&#182;</a>
              </div>
              <p>You cannot override the <code>stack</code>, <code>errors</code>, or <code>name</code> properties.</p>

            </div>

        </li>


        <li id="section-193">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-193">&#182;</a>
              </div>
              <h2 id="property-serialization-json">Property Serialization JSON</h2>

            </div>

        </li>


        <li id="section-194">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-194">&#182;</a>
              </div>
              <p>Error properties are written to the stack trace as JSON. If run this unit
test from the command line, you will have seen stack traces that include
formatted JSON of the properties.</p>

            </div>

        </li>


        <li id="section-195">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-195">&#182;</a>
              </div>
              <p>We use JSON instead of <code>util.inspect()</code> because we want the ability to
gather our stack trace messages from our production logs and parse them
for programmatic analysis.</p>

            </div>

        </li>


        <li id="section-196">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-196">&#182;</a>
              </div>
              <p>There are object trees that JSON cannot serialize, however. We’ve made
some accommodations so that JSON will do its best to serialize as much as
it can.</p>

            </div>

        </li>


        <li id="section-197">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-197">&#182;</a>
              </div>
              <p>It’s unreasonable to insist that only valid JSON objects are allowed as
error properties. A function could be trying to say, “I expected an
integer but instead you gave me this.” If the bad argument the function
is trying to report contains circular references we don’t want
<code>JSON.stringify()</code> to chime in with its own exception.</p>

            </div>

        </li>


        <li id="section-198">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-198">&#182;</a>
              </div>
              <p>If given JSON that <code>JSON.stringify()</code> cannot stringify, rather than
failing silently, or worse, throwing an exception, Interrupt tries to
accommodate the invalid JSON.</p>

            </div>

        </li>


        <li id="section-199">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-199">&#182;</a>
              </div>
              <p>This specialized <code>JSON</code> serialization is exposed by
<code>Interrupt.JSON.stringify()</code>. There is an associated
<code>Interrupt.JSON.parse()</code> to go with it.</p>

            </div>

        </li>


        <li id="section-200">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-200">&#182;</a>
              </div>
              <p>We always serialize JSON with a four space indent.</p>

            </div>

        </li>


        <li id="section-201">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-201">&#182;</a>
              </div>
              <p>Ordinary JSON serializes and parses like ordinary JSON.</p>

            </div>

        </li>


        <li id="section-202">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-202">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- serializing ordinary JSON ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> object = {
            <span class="hljs-attr">missing</span>: <span class="hljs-literal">null</span>,
            <span class="hljs-attr">number</span>: <span class="hljs-number">1</span>,
            <span class="hljs-attr">string</span>: <span class="hljs-string">'string'</span>,
            <span class="hljs-attr">array</span>: [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ],
            <span class="hljs-attr">object</span>: { <span class="hljs-attr">key</span>: <span class="hljs-string">'value'</span> }
        }

        <span class="hljs-keyword">const</span> stringified = Interrupt.JSON.stringify(object)

        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${stringified}</span>\n`</span>)

        <span class="hljs-keyword">const</span> parsed = Interrupt.JSON.parse(stringified)


        okay(parsed, object, <span class="hljs-string">'serialize and parse ordinary JSON'</span>)
    }</pre></div></div>

        </li>


        <li id="section-203">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-203">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-204">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-204">&#182;</a>
              </div>
              <p>Circular references are supported and they can be parsed, but they make
the JSON output harder to read. There will be reference placeholders in
the output.</p>

            </div>

        </li>


        <li id="section-205">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-205">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- serializing JSON with circular references ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> object = { <span class="hljs-attr">c</span>: <span class="hljs-number">1</span> }

        <span class="hljs-keyword">const</span> stringified = Interrupt.JSON.stringify({ <span class="hljs-attr">a</span>: object, <span class="hljs-attr">b</span>: object })

        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${stringified}</span>\n`</span>)

        <span class="hljs-keyword">const</span> parsed = Interrupt.JSON.parse(stringified)

        okay(parsed.a === parsed.b, <span class="hljs-string">'serialize and parse JSON with circular references'</span>)
    }</pre></div></div>

        </li>


        <li id="section-206">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-206">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-207">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-207">&#182;</a>
              </div>
              <p>Undefined will be serialized and parsed. <code>JSON.stringify()</code> drops values
that are <code>undefined</code>, but seeing that a value is <code>undefined</code> might
explain clarify the cause of an error.</p>

            </div>

        </li>


        <li id="section-208">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-208">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- serializing JSON with undefined members ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> object = { <span class="hljs-attr">missing</span>: <span class="hljs-literal">undefined</span> }

        <span class="hljs-keyword">const</span> stringified = Interrupt.JSON.stringify(object)

        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${stringified}</span>\n`</span>)

        <span class="hljs-keyword">const</span> parsed = Interrupt.JSON.parse(stringified, <span class="hljs-string">'\n'</span>)

        okay(parsed, object, <span class="hljs-string">'serialize and parse JSON with undefined members'</span>)
    }</pre></div></div>

        </li>


        <li id="section-209">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-209">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-210">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-210">&#182;</a>
              </div>
              <p>If your JSON has an array that just happens to start with a
<code>&#39;_referenced&#39;</code>, <code>&#39;_undefined&#39;</code>, or <code>&#39;_array&#39;</code> string, it is escaped with
an <code>_array</code> type specifier so it can be serialized and parsed.</p>

            </div>

        </li>


        <li id="section-211">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-211">&#182;</a>
              </div>
              <p>We’re able to parse circular references and undefined we replace them a
place-holder. The place-holder is an array that starts with a string
indicating the type, <code>&#39;_referenced&#39;</code>, or <code>&#39;_undefined&#39;</code> and has any
additinal information in the rest of the array. On parsing we detect
these special arrays by looking at the first element.</p>

            </div>

        </li>


        <li id="section-212">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-212">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- escaping type specifiers in JSON ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> object = { <span class="hljs-attr">array</span>: [ <span class="hljs-string">'_reference'</span>, [ <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span> ] ] }

        <span class="hljs-keyword">const</span> stringified = Interrupt.JSON.stringify(object)

        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${stringified}</span>\n`</span>)

        <span class="hljs-keyword">const</span> parsed = Interrupt.JSON.parse(stringified, <span class="hljs-string">'\n'</span>)

        okay(parsed, object, <span class="hljs-string">'serialize and parse JSON parsing type specifiers'</span>)
    }</pre></div></div>

        </li>


        <li id="section-213">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-213">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-214">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-214">&#182;</a>
              </div>
              <p>Errors are serialized specially. JSON treats error an object and neither
<code>message</code>, nor <code>stack</code> are enumerable. If there are no additional
properties you simply see an empty array.</p>

            </div>

        </li>


        <li id="section-215">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-215">&#182;</a>
              </div>
              <p>Interrupt’s JSON will serialize the <code>message</code> and <code>stack</code>.</p>

            </div>

        </li>


        <li id="section-216">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-216">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- default JSON serialization of Error ---\n'</span>)
    {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'thrown'</span>))}</span>\n`</span>)

        <span class="hljs-keyword">const</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'thrown'</span>)
        error.code = <span class="hljs-string">'ENOENT'</span>
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(error)}</span>\n`</span>)
    }</pre></div></div>

        </li>


        <li id="section-217">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-217">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-218">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-218">&#182;</a>
              </div>
              <p>Interrupt’s JSON will serialize the <code>message</code>, <code>stack</code> and any additional
properties set on the <code>Error</code> object. It cannot, however, parse the JSON
and construct the object as an <code>Error</code> type. It will be a plain <code>Object</code>.</p>

            </div>

        </li>


        <li id="section-219">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-219">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- Interrupt JSON serialization of Error ---\n'</span>)
    {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${Interrupt.<span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'thrown'</span>))}</span>\n`</span>)

        <span class="hljs-keyword">const</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'thrown'</span>)
        error.code = <span class="hljs-string">'ENOENT'</span>
        <span class="hljs-keyword">const</span> stringified = Interrupt.JSON.stringify(error)

        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${stringified}</span>\n`</span>)

        <span class="hljs-keyword">const</span> parsed = Interrupt.JSON.parse(stringified)
        okay(parsed.message, <span class="hljs-string">'thrown'</span>, <span class="hljs-string">'parsed JSON serialized error message'</span>)
        okay(parsed.code, <span class="hljs-string">'ENOENT'</span>, <span class="hljs-string">'parsed JSON serialized error property'</span>)
        okay(!(parsed <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span>), <span class="hljs-string">'does not recreate Error type'</span>)
    }</pre></div></div>

        </li>


        <li id="section-220">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-220">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-221">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-221">&#182;</a>
              </div>
              <p>Functions are converted to their <code>toString()</code> value so you can see their
source if it is available. They will not be parsed back into functions.</p>

            </div>

        </li>


        <li id="section-222">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-222">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- Interrupt JSON serialaization of a function ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> stringified = Interrupt.JSON.stringify({ <span class="hljs-attr">f</span>: <span class="hljs-function"><span class="hljs-params">number</span> =&gt;</span> number + <span class="hljs-number">1</span> })

        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${stringified}</span>\n`</span>)

        <span class="hljs-keyword">const</span> parsed = Interrupt.JSON.parse(stringified)

        okay(parsed.f, <span class="hljs-string">'number =&gt; number + 1'</span>, <span class="hljs-string">'serialize function to string in JSON'</span>)
    }</pre></div></div>

        </li>


        <li id="section-223">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-223">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-224">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-224">&#182;</a>
              </div>
              <p><strong>TODO</strong> Left off documentation here.</p>

            </div>

        </li>


        <li id="section-225">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-225">&#182;</a>
              </div>
              <p>The <code>Interrupt.JSON</code> functions do not support custom <code>replacer</code> or
<code>reviver</code> functions and you cannot adjust the indent, it is always four
spaces.</p>

            </div>

        </li>


        <li id="section-226">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-226">&#182;</a>
              </div>
              <p>Otherwise, Interrupt JSON behaves the way ordinary <code>JSON</code> behaves.
Objects lose their type information, <code>toJSON</code> is called if it is defined
so objects like <code>Buffer</code> convert to a JSON representation, JSON itself
converts of <code>Date</code> to strings. You won’t always get back from JSON the
same types you put in, but you know that.</p>

            </div>

        </li>


        <li id="section-227">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-227">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- serializing JSON with `toJSON()` defined and `Date` members ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> stringified = Interrupt.JSON.stringify({
            <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">0</span>),
            <span class="hljs-attr">buffer</span>: Buffer.from(<span class="hljs-string">'a'</span>)
        })

        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${stringified}</span>\n`</span>)

        <span class="hljs-keyword">const</span> parsed = Interrupt.JSON.parse(stringified, <span class="hljs-string">'\n'</span>)

        okay(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(parsed.date), <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">0</span>), <span class="hljs-string">'able to reconstruct date using String constructor'</span>)
        okay(parsed.buffer, {
            <span class="hljs-attr">type</span>: <span class="hljs-string">"Buffer"</span>,
            <span class="hljs-attr">data</span>: [ <span class="hljs-number">97</span> ]
        }, <span class="hljs-string">'`Buffer` JSON member converted to JSON using `Buffer.toJSON()`'</span>)
    }</pre></div></div>

        </li>


        <li id="section-228">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-228">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-229">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-229">&#182;</a>
              </div>
              <p>For the most part, you won’t be able to parse the JSON and get back the
original objects if they are not plain <code>objects</code>. That isn’t really
important for reporting purposes however, just don’t be surprised is all.</p>

            </div>

        </li>


        <li id="section-230">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-230">&#182;</a>
              </div>
              <h2 id="formatted-messages">Formatted Messages</h2>

            </div>

        </li>


        <li id="section-231">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-231">&#182;</a>
              </div>
              <p>Messages are formatted using <code>sprintf-fs</code> which has a named parameter
syntax so we can use our properties object as our <code>sprintf</code> parameters.</p>

            </div>

        </li>


        <li id="section-232">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-232">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- formatted messages ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises

        <span class="hljs-keyword">const</span> ReaderError = Interrupt.create(<span class="hljs-string">'ConfigError'</span>, {
            <span class="hljs-attr">FILE_READ_ERROR</span>: <span class="hljs-string">'unable to read file: %(filename)s'</span>
        })

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read</span> (<span class="hljs-params">filename</span>) </span>{
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> fs.readFile(filename)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ReaderError(<span class="hljs-string">'FILE_READ_ERROR'</span>, { filename })
            }
        }

        <span class="hljs-keyword">const</span> filename = path.join(__dirname, <span class="hljs-string">'missing.txt'</span>)

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">await</span> read(filename)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(Interrupt.message(error), <span class="hljs-string">`unable to read file: <span class="hljs-subst">${filename}</span>`</span>, <span class="hljs-string">'sprintf message formatted'</span>)
            okay(error.filename, filename, <span class="hljs-string">'sprintf example filename property set'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-233">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-233">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-234">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-234">&#182;</a>
              </div>
              <p>If <code>sprintf</code> is unable to format the message due to an error in the
message format, the message format will be used as is.</p>

            </div>

        </li>


        <li id="section-235">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-235">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises

        <span class="hljs-keyword">const</span> ReaderError = Interrupt.create(<span class="hljs-string">'ConfigError'</span>, {
            <span class="hljs-attr">FILE_READ_ERROR</span>: <span class="hljs-string">'unable to read file: %(filename)'</span>
        })

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read</span> (<span class="hljs-params">filename</span>) </span>{
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> fs.readFile(filename)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ReaderError(<span class="hljs-string">'FILE_READ_ERROR'</span>)
            }
        }

        <span class="hljs-keyword">const</span> filename = path.join(__dirname, <span class="hljs-string">'missing.txt'</span>)

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">await</span> read(filename)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(Interrupt.message(error), <span class="hljs-string">`unable to read file: %(filename)`</span>, <span class="hljs-string">'format was missing a sprintf type specifier'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-236">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-236">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-237">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-237">&#182;</a>
              </div>
              <p>To use a parameter in the format you <strong>must</strong> put it in the properties
object and it will become a property of the exception. If you really want
to use a parameter but not have it become a property of the exception
prefix add an underbar to both the property in the properties object and
the <code>sprintf</code> format.</p>

            </div>

        </li>


        <li id="section-238">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-238">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- sprintf-only properties ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> ReaderError = Interrupt.create(<span class="hljs-string">'ConfigError'</span>, {
            <span class="hljs-attr">INVALID_FILENAME</span>: <span class="hljs-string">`filename must be a string, received: %(_type)s`</span>,
            <span class="hljs-attr">FILE_READ_ERROR</span>: <span class="hljs-string">'unable to read file: %(filename)s'</span>
        })

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read</span> (<span class="hljs-params">filename</span>) </span>{
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> filename != <span class="hljs-string">'string'</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ReaderError(<span class="hljs-string">'INVALID_FILENAME'</span>, { <span class="hljs-attr">_type</span>: <span class="hljs-keyword">typeof</span> filename })
            }
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> fs.readFile(filename)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ReadError(<span class="hljs-string">'FILE_READ_ERROR'</span>, { filename })
            }
        }

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">await</span> read([])
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(!(<span class="hljs-string">'_type'</span> <span class="hljs-keyword">in</span> error), <span class="hljs-string">'sprintf-only property is not a property of the exception'</span>)
            okay(Interrupt.message(error), <span class="hljs-string">'filename must be a string, received: object'</span>, <span class="hljs-string">'sprintf-only property available for sprintf'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-239">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-239">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-240">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-240">&#182;</a>
              </div>
              <p>In the above example we decided add the incorrect type to the error
message, but decided against making it a property of the exception. For
an assertion that should be raised by unit testing, the message ought to
be enough.</p>

            </div>

        </li>


        <li id="section-241">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-241">&#182;</a>
              </div>
              <p>Because underbars make properties disappear you should be careful not to
dump arbitrary objects into your properties with destructuring.</p>

            </div>

        </li>


        <li id="section-242">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-242">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- ruining a properties object with destructuring ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> ConfigError = Interrupt.create(<span class="hljs-string">'ConfigError'</span>, {
            <span class="hljs-attr">PARAM_MISSING</span>: <span class="hljs-string">'config parameter missing'</span>,
            <span class="hljs-attr">INVALID_PARAM_TYPE</span>: <span class="hljs-string">'invalid config parameter type'</span>
        })

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertConfig</span> (<span class="hljs-params">config</span>) </span>{
            <span class="hljs-keyword">if</span> (config.settings == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'PARAM_MISSING'</span>, { ...config })
            }
            <span class="hljs-keyword">if</span> (config.settings.volume != <span class="hljs-string">'number'</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'INVALID_PARAM_TYPE'</span>, { ...config })
            }
        }

        <span class="hljs-keyword">try</span> {
            assertConfig({ <span class="hljs-attr">_settings</span>: { <span class="hljs-attr">volume</span>: <span class="hljs-number">0</span> } })
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay({ ...error }, { <span class="hljs-attr">code</span>: <span class="hljs-string">'PARAM_MISSING'</span> }, <span class="hljs-string">'desired context infomration removed because of underbar'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-243">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-243">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-244">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-244">&#182;</a>
              </div>
              <p>This is not a good thing to do in any case.</p>

            </div>

        </li>


        <li id="section-245">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-245">&#182;</a>
              </div>
              <p>Only properties with underbar’d names at the top level of the properties
object are removed. We do not recursively search for underbar’d
properties to remove.</p>

            </div>

        </li>


        <li id="section-246">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-246">&#182;</a>
              </div>
              <p>We can fix the above by removing the destructuring.</p>

            </div>

        </li>


        <li id="section-247">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-247">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- explicitly set your property names ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> ConfigError = Interrupt.create(<span class="hljs-string">'ConfigError'</span>, {
            <span class="hljs-attr">PARAM_MISSING</span>: <span class="hljs-string">'config parameter missing'</span>,
            <span class="hljs-attr">INVALID_PARAM_TYPE</span>: <span class="hljs-string">'invalid config parameter type'</span>
        })

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertConfig</span> (<span class="hljs-params">config</span>) </span>{
            <span class="hljs-keyword">if</span> (config.settings == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'PARAM_MISSING'</span>, { config })
            }
            <span class="hljs-keyword">if</span> (config.settings.volume != <span class="hljs-string">'number'</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'INVALID_PARAM_TYPE'</span>, { config })
            }
        }

        <span class="hljs-keyword">try</span> {
            assertConfig({ <span class="hljs-attr">_settings</span>: { <span class="hljs-attr">volume</span>: <span class="hljs-number">0</span> } })
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay({ ...error }, {
                <span class="hljs-attr">code</span>: <span class="hljs-string">'PARAM_MISSING'</span>,
                <span class="hljs-attr">config</span>: { <span class="hljs-attr">_settings</span>: { <span class="hljs-attr">volume</span>: <span class="hljs-number">0</span> } }
            }, <span class="hljs-string">'we know our property names'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-248">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-248">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-249">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-249">&#182;</a>
              </div>
              <h2 id="message-tables">Message Tables</h2>

            </div>

        </li>


        <li id="section-250">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-250">&#182;</a>
              </div>
              <p>You might not be able to create a message generic enough for a particular
code, or you might want to use generialized codes with customized
messages.</p>

            </div>

        </li>


        <li id="section-251">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-251">&#182;</a>
              </div>
              <p><strong>TODO</strong> Stabbing at how to say this. Rewrite.</p>

            </div>

        </li>


        <li id="section-252">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-252">&#182;</a>
              </div>
              <p>Codes and messages are a matter of taste. You might want to have a small
set of generic codes but a lot of detailed messages and error properties
for context. If this is the case, you’ll have to litter the specialized
messages throughout your program.</p>

            </div>

        </li>


        <li id="section-253">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-253">&#182;</a>
              </div>
              <p>You can instead define a message table.</p>

            </div>

        </li>


        <li id="section-254">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-254">&#182;</a>
              </div>
              <p>A default defines a <code>code</code> property that is either the string name of an
existing code, the symbol for an existing code or one of the code objects
in the code object map passed into a code definition function.</p>

            </div>

        </li>


        <li id="section-255">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-255">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-keyword">const</span> ConfigError = Interrupt.create(<span class="hljs-string">'ConfigError'</span>, [
            <span class="hljs-string">'MISSING_PARAM'</span>, <span class="hljs-string">'INVALID_PARAM_TYPE'</span>
        ], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">{ Codes }</span>) </span>{
            <span class="hljs-keyword">return</span> {</pre></div></div>

        </li>


        <li id="section-256">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-256">&#182;</a>
              </div>
              <p><em>Specify by code name.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>                <span class="hljs-string">'SETTINGS_MISSING'</span>: {
                    <span class="hljs-attr">code</span>: <span class="hljs-string">'MISSING_PARAM'</span>,
                    <span class="hljs-attr">message</span>: <span class="hljs-string">'the settings property is missing'</span>
                },</pre></div></div>

        </li>


        <li id="section-257">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-257">&#182;</a>
              </div>
              <p><em>Specify by code symbol.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>                <span class="hljs-string">'VOLUME_MISSING'</span>: {
                    <span class="hljs-attr">code</span>: Codes.MISSING_PARAM.symbol,
                    <span class="hljs-attr">message</span>: <span class="hljs-string">'the volume property is missing'</span>
                },</pre></div></div>

        </li>


        <li id="section-258">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-258">&#182;</a>
              </div>
              <p><em>Easiest to read, just the <code>code</code> object itself.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>                <span class="hljs-string">'INVALID_VOLUME_TYPE'</span>: {
                    <span class="hljs-attr">code</span>: Codes.INVALID_PARAM_TYPE,
                    <span class="hljs-attr">message</span>: <span class="hljs-string">'the volume must be integer, got type: %(_type)s'</span>
                }
            }
        })

        okay(ConfigError.INVALID_PARAM_TYPE != <span class="hljs-literal">null</span>, <span class="hljs-string">'defined symbol property on class'</span>)
        okay(ConfigError.INVALID_VOLUME_TYPE == <span class="hljs-literal">null</span>, <span class="hljs-string">'did not define message table as symbol'</span>)
        okay(ConfigError.code(<span class="hljs-string">'INVALID_VOLUME_TYPE'</span>) == <span class="hljs-literal">null</span>, <span class="hljs-string">'not available from codes either'</span>)
        okay(ConfigError.codes.sort(), [ <span class="hljs-string">'INVALID_PARAM_TYPE'</span>, <span class="hljs-string">'MISSING_PARAM'</span> ], <span class="hljs-string">'codes created, not templates'</span>)

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertConfig</span> (<span class="hljs-params">config</span>) </span>{
            <span class="hljs-keyword">if</span> (!(<span class="hljs-string">'settings'</span> <span class="hljs-keyword">in</span> config)) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'SETTINGS_MISSING'</span>)
            }
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> config.settings != <span class="hljs-string">'object'</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'INVALID_SETTINGS_TYPE'</span>, { <span class="hljs-attr">_type</span>: <span class="hljs-keyword">typeof</span> config.settings })
            }
            <span class="hljs-keyword">if</span> (!(<span class="hljs-string">'volume'</span> <span class="hljs-keyword">in</span> config.settings)) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'VOLUME_MISSING'</span>)
            }
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> config.settings.volume != <span class="hljs-string">'number'</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'INVALID_VOLUME_TYPE'</span>, { <span class="hljs-attr">_type</span>: <span class="hljs-keyword">typeof</span> config.settings.volume })
            }
        }

        <span class="hljs-keyword">try</span> {
            assertConfig({ <span class="hljs-attr">settings</span>: { <span class="hljs-attr">volume</span>: <span class="hljs-string">'loud'</span> } })
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.code, <span class="hljs-string">'INVALID_PARAM_TYPE'</span>, <span class="hljs-string">'aliased code set'</span>)
            okay(error.symbol, ConfigError.INVALID_PARAM_TYPE, <span class="hljs-string">'aliased code set'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-259">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-259">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-260">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-260">&#182;</a>
              </div>
              <p><strong>TODO</strong> Getting poorly written here abouts.</p>

            </div>

        </li>


        <li id="section-261">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-261">&#182;</a>
              </div>
              <p>When you specify a symbol or a code in your definition it is used as an
alias for that code. The properties and format for that code are used but
they are overwritten by the alias. The referenced code is used for
exceptions code. Aliases can reference aliases.</p>

            </div>

        </li>


        <li id="section-262">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-262">&#182;</a>
              </div>
              <p>You cannot declare an alias or code more than once in <code>create()</code>. You
will inherit the aliases of the super class and they can be overridden in
the sub class.</p>

            </div>

        </li>


        <li id="section-263">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-263">&#182;</a>
              </div>
              <p>You can specify both a symbol and a code, but they must agree.</p>

            </div>

        </li>


        <li id="section-264">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-264">&#182;</a>
              </div>
              <h2 id="nested-exceptions">Nested Exceptions</h2>

            </div>

        </li>


        <li id="section-265">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-265">&#182;</a>
              </div>
              <p>When you want to throw an exception based on a exception you caught you
can pass that exception’s error into the constructor. The <code>errors</code>
property of the exception will contain the cause. Any argument that is an
object that is <code>instance Error</code> will be added to the <code>errors</code>.</p>

            </div>

        </li>


        <li id="section-266">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-266">&#182;</a>
              </div>
              <p>If you pass in more than one error they will both be added to the errors
array. (<strong>TODO</strong> An example with a primary attempt and a fallback and
they both fail. Hmm… Now I have an aggregate but that is for the
context example, this example is still good.)</p>

            </div>

        </li>


        <li id="section-267">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-267">&#182;</a>
              </div>
              <p>Any <code>Array</code> argument to the constructor is treated as an array of nested
errors and added to the error array.</p>

            </div>

        </li>


        <li id="section-268">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-268">&#182;</a>
              </div>
              <p>You can mix adding both arrays and errors directly.</p>

            </div>

        </li>


        <li id="section-269">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-269">&#182;</a>
              </div>
              <p>Any type can be thrown from JavaScript. If can’t be certain that the
error you caught is <code>instanceof Error</code>, simply wrap it in an array.</p>

            </div>

        </li>


        <li id="section-270">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-270">&#182;</a>
              </div>
              <p><strong>TODO</strong> Example of any type of error.</p>

            </div>

        </li>


        <li id="section-271">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-271">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-272">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-272">&#182;</a>
              </div>
              <h2 id="stack-trace-limit">Stack Trace Limit</h2>

            </div>

        </li>


        <li id="section-273">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-273">&#182;</a>
              </div>
              <p>An integer greater than or equal to zero, or Infinity is interpreted as a
stack trace limit. It is used to temporarily set <code>Error.stackTraceLimit</code>
for during the construction of the exception. <code>Error.stackTraceLimit</code> is
restored to its original value after the exception is constructed.</p>

            </div>

        </li>


        <li id="section-274">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-274">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
    }</pre></div></div>

        </li>


        <li id="section-275">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-275">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-276">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-276">&#182;</a>
              </div>
              <p>In our nested error examples so far we’ve always specified a single
nested error so we’ve added context to wrapper error. When you create an
aggregate exception, you don’t have a good way to associate properties in
the wrapper error with an error at a specific index in the nested errors
array.</p>

            </div>

        </li>


        <li id="section-277">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-277">&#182;</a>
              </div>
              <p>To provide context for each nested error, you can create a wrapper error
for each nested error. Now you have an aggregate error with an array of
context wrapper errors containing the actual errors. Yes, you can do
this, and yes it’s a bit much. This is where the stack trace limit can
help.</p>

            </div>

        </li>


        <li id="section-278">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-278">&#182;</a>
              </div>
              <p>The stack trace can start to get too verbose. Each wrapper error will add
a stack trace and that stack trace is often superflous. If the aggregate
error provides a stack trace that points to the right function in your
application and the context wrapper errors merely repeat that stack
trace plus a frame, go ahead and get rid of it by setting a stack trace
limit of zero. The context wrapper exceptions will appear without a stack
trace or stack trace header merely providing some context.</p>

            </div>

        </li>


        <li id="section-279">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-279">&#182;</a>
              </div>
              <p><strong>TODO</strong> Do we want to maybe make the code a part of the exception name?
No. No way to distinquish the class name from the code without
introducing some additional funny character. What’s the big deal about a
funny character? <code>#</code> and you encourage codes.</p>

            </div>

        </li>


        <li id="section-280">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-280">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- nested error context wrapper ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises

        <span class="hljs-keyword">const</span> ConfigError = Interrupt.create(<span class="hljs-string">'ConfigError'</span>, {
            <span class="hljs-attr">UNABLE_TO_READ_DIRECTORY</span>: <span class="hljs-string">'unable to read directory'</span>,
            <span class="hljs-attr">UNABLE_TO_READ_FILE</span>: <span class="hljs-string">'unable to read file'</span>
        })

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">slurpDirectory</span> (<span class="hljs-params">dirname</span>) </span>{
            <span class="hljs-keyword">let</span> dir
            <span class="hljs-keyword">try</span> {
                dir = <span class="hljs-keyword">await</span> fs.readdir(dirname)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'UNABLE_TO_READ_DIRECTORY'</span>, { dirname })
            }
            <span class="hljs-keyword">const</span> promises = [], errors = [], files = []
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> file <span class="hljs-keyword">of</span> dir) {
                promises.push(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                    <span class="hljs-keyword">const</span> filename = path.join(dirname, file)
                    <span class="hljs-keyword">try</span> {
                        <span class="hljs-keyword">await</span> files.push(<span class="hljs-keyword">await</span> fs.readFile(filename))
                    } <span class="hljs-keyword">catch</span> (error) {
                        errors.push(<span class="hljs-keyword">new</span> ConfigError.Error(<span class="hljs-number">0</span>, <span class="hljs-string">'UNABLE_TO_READ_FILE'</span>, error, { filename }))
                    }
                } ())
            }
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> promise <span class="hljs-keyword">of</span> promises) {
                <span class="hljs-keyword">await</span> promise
            }
            <span class="hljs-keyword">if</span> (errors.length) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigError(<span class="hljs-string">'UNABLE_TO_READ_DIRECTORY'</span>, errors, { dirname })
            }
            <span class="hljs-keyword">return</span> files
        }

        <span class="hljs-keyword">const</span> dirname = path.join(__dirname, <span class="hljs-string">'tmp'</span>, <span class="hljs-string">'eisdir'</span>)

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">await</span> slurpDirectory(dirname)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-281">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-281">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-282">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-282">&#182;</a>
              </div>
              <p>Alternatively, you could set the stack trace to <code>1</code> to get just a
filename and line number on the nested wrapper exception.</p>

            </div>

        </li>


        <li id="section-283">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-283">&#182;</a>
              </div>
              <p>Trimming stack traces is worthwhile. We know that JavaScript won’t give
us a continguous stack trace, so we become accustomed to using what we
get to poke around, so we learn to trim the cruft down to just what we
need to navigate the source post mortem.</p>

            </div>

        </li>


        <li id="section-284">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-284">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-285">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-285">&#182;</a>
              </div>
              <p>Why don’t you need the additional stack trace? Okay, I’m going to add
this facility because it exists currently, but the new stack trace
adjustment facilities suggest that it is a mistake. Maybe this comes back
out. Can see how you might have a module where all the user really cares
about is the point of entry, not about the calls launched within the
module function.</p>

            </div>

        </li>


        <li id="section-286">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-286">&#182;</a>
              </div>
              <p><strong>TODO</strong> In Destructable, see if there is space for a launch marker. A <code>$
=&gt; ()</code> function that can encase the launch point of the strand.</p>

            </div>

        </li>


        <li id="section-287">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-287">&#182;</a>
              </div>
              <h2 id="callee">Callee</h2>

            </div>

        </li>


        <li id="section-288">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-288">&#182;</a>
              </div>
              <p>Sometime you want the stack trace to exclude the upper most stack frames.
This is useful when creating assertion functions where the top of the
stack trace should be the point where the assertion was called, not the
point where the assertion function created the exception.</p>

            </div>

        </li>


        <li id="section-289">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-289">&#182;</a>
              </div>
              <p>To specify a callee you pass in an options object as the first argument
to the constructor.</p>

            </div>

        </li>


        <li id="section-290">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-290">&#182;</a>
              </div>
              <p><strong>TODO</strong> The code or message format is always required, but somtimes it
is not desired. If you want to specify that you do not want to use a code
nor a message pass in null. (No, pass in an empty object!) This is useful
when you are overriding properties</p>

            </div>

        </li>


        <li id="section-291">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-291">&#182;</a>
              </div>
              <h2 id="named-arguments">Named Arguments</h2>

            </div>

        </li>


        <li id="section-292">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-292">&#182;</a>
              </div>
              <p>Sometimes a one-liner gets too hard to read. Breaking up the declaration
across multiple lines helps, and while you’re at it, you may as well give
a name to what you’re trying to do.</p>

            </div>

        </li>


        <li id="section-293">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-293">&#182;</a>
              </div>
              <h2 id="constructor-argument-order">Constructor Argument Order</h2>

            </div>

        </li>


        <li id="section-294">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-294">&#182;</a>
              </div>
              <p>We have an ambiguity in the way we call our constructor. We have both an
options object and a properties object. If you want to use an options
object but then override it with custom properties you have to …</p>

            </div>

        </li>


        <li id="section-295">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-295">&#182;</a>
              </div>
              <p>All of the above parameters can be specified with an <code>options</code> object as
the first parameter to the constructor.</p>

            </div>

        </li>


        <li id="section-296">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-296">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- construct an Interrupt with named parameters ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> ParseError = Interrupt.create(<span class="hljs-string">'ParseError'</span>, {
            <span class="hljs-attr">INVALID_JSON</span>: <span class="hljs-string">'unable to parse JSON string'</span>
        })

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span> (<span class="hljs-params">json</span>) </span>{
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(json)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ParseError({
                    <span class="hljs-attr">code</span>: <span class="hljs-string">'INVALID_JSON'</span>,
                    <span class="hljs-attr">errors</span>: [ error ],
                    <span class="hljs-attr">json</span>: json,
                    <span class="hljs-string">'#callee'</span>: parse
                })
            }
        }

        <span class="hljs-keyword">try</span> {
            parse(<span class="hljs-string">'!'</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.code, <span class="hljs-string">'INVALID_JSON'</span>, <span class="hljs-string">'named parameters code set'</span>)
            okay(error.json, <span class="hljs-string">'!'</span>, <span class="hljs-string">'named parameters property set'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-297">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-297">&#182;</a>
              </div>
              <p>At times you might want to construct exceptions programmatically, merging
context that is common to a scope with specific context for a particular
exception. You can create an options object that is common to a scope.</p>

            </div>

        </li>


        <li id="section-298">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-298">&#182;</a>
              </div>
              <p>You can then call the exception constructor with the <code>options</code> object
followed by any positional parameters. The positional parameters will be
merged into the <code>options</code> object before constructing the object.</p>

            </div>

        </li>


        <li id="section-299">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-299">&#182;</a>
              </div>
              <p>We said that you can’t override the <code>code</code> property of an exception with
a <code>code</code> property in the <code>context</code> object, but you can override the
<code>code</code> property of the <code>options</code> object with a positional <code>code</code> property
in the constructor.</p>

            </div>

        </li>


        <li id="section-300">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-300">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {</pre></div></div>

        </li>


        <li id="section-301">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-301">&#182;</a>
              </div>
              <p><strong>TODO</strong> Example.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    }</pre></div></div>

        </li>


        <li id="section-302">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-302">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-303">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-303">&#182;</a>
              </div>
              <p>Construction has no assertions. If you create <code>new Interrupt</code> with
incorrect parameters the constructor will do it’s best to create
something from what you give it. Exception code is often skipped in the
the unit tests. We don’t want to throw assertions because you put the
arguments in the wrong order. We want to report the application exception
and if it is missing context or the formatted message contains a dangling
participle that ought to be apparent in stack trace message.</p>

            </div>

        </li>


        <li id="section-304">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-304">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-305">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-305">&#182;</a>
              </div>
              <p>If you specify a message for which there is no error code, it is used as
the <code>message</code> property and the <code>code</code> property is not set.</p>

            </div>

        </li>


        <li id="section-306">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-306">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-307">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-307">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-308">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-308">&#182;</a>
              </div>
              <p><strong>TODO</strong>: No more catching by type claims. Point people at <code>rescue</code> for
that, since that is where that happens.</p>
<p>Here is a real to do list for the documentation.</p>
<ul>
<li>Formatted messages. (Really do want to use sprintf.)</li>
<li>Object properties.</li>
<li>Unserialized properties (just set them.)</li>
<li>Named parameters.</li>
</ul>

            </div>

        </li>


        <li id="section-309">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-309">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
    }</pre></div></div>

        </li>


        <li id="section-310">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-310">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-311">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-311">&#182;</a>
              </div>
              <h2 id="class-member-errors">Class Member Errors</h2>
<p>When creating an error class using Interrupt, if you want to avoid name
collisions with the numerous errors that are already in the global
namespace, you can assign it as a static member to a class in your module
and give it a dot qualified name.</p>

            </div>

        </li>


        <li id="section-312">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-312">&#182;</a>
              </div>
              <p>For example, imagine we have a <code>Synax</code> class in our module. We’d like to
have <code>SyntaxError</code> specific to our module but <code>SyntaxError</code> a
<code>SyntaxError</code> already exists in the global namespace. We can create
instead create a <code>Syntax.Error</code>, an error that has a dot qualfiied name
and is a static member of our <code>Syntax</code> class.</p>

            </div>

        </li>


        <li id="section-313">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-313">&#182;</a>
              </div>
              <p><strong>TODO</strong> Terrible example. Just rewrite any of your existing file opening
examples. You’re talking about <code>assert</code> before you’ve introduced it. The
example is more contrived than any you’re written before.</p>

            </div>

        </li>


        <li id="section-314">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-314">&#182;</a>
              </div>
              <p>Also, any test of the file to see if it contains hippopotus will succeed
without having to write hippopotus anywhere except in the test.</p>

            </div>

        </li>


        <li id="section-315">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-315">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'--- qualified Error class names ---\n'</span>)
    {
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Syntax</span> (<span class="hljs-params"></span>) </span>{
        }

        Syntax.prototype.validate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">string</span>) </span>{
            Syntax.Error.assert(string != <span class="hljs-literal">null</span>, <span class="hljs-string">'SYNTAX_IS_NULL'</span>)
            <span class="hljs-keyword">return</span> ~string.indexOf(<span class="hljs-string">'hippopotomus'</span>)
        }

        Syntax.Error = Interrupt.create(<span class="hljs-string">'Syntax.Error'</span>, {
            <span class="hljs-attr">SYNTAX_IS_NULL</span>: <span class="hljs-string">'the syntax validation method received a null argument'</span>
        })

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">const</span> syntax = <span class="hljs-keyword">new</span> Syntax
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Syntax is valid? <span class="hljs-subst">${syntax.validate(<span class="hljs-literal">null</span>)}</span>`</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.name, <span class="hljs-string">'Syntax.Error'</span>, <span class="hljs-string">'name allowed to have dot qualifiers'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-316">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-316">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-317">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-317">&#182;</a>
              </div>
              <p>These days I’m targeting Node.js 12 or greater, which has a <code>static</code>
keyword that makes declaration easier.</p>

            </div>

        </li>


        <li id="section-318">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-318">&#182;</a>
              </div>
              <p><strong>TODO</strong> Who cares about these days? Interrupt targets Node.js 12.
Enough!</p>

            </div>

        </li>


        <li id="section-319">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-319">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'--- qualified Error class names in ES6 classes ---\n'</span>)
    {
        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Syntax</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Syntax.Error'</span>, {
                <span class="hljs-attr">SYNTAX_IS_NULL</span>: <span class="hljs-string">'the syntax validate method received a null argument'</span>
            })

            validate (string) {
                Syntax.Error.assert(string != <span class="hljs-literal">null</span>, <span class="hljs-string">'SYNTAX_IS_NULL'</span>)
                <span class="hljs-keyword">return</span> ~string.indexOf(<span class="hljs-string">'hippopotomus'</span>)
            }
        }

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">const</span> syntax = <span class="hljs-keyword">new</span> Syntax
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Syntax is valid? <span class="hljs-subst">${syntax.validate(<span class="hljs-literal">null</span>)}</span>`</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.name, <span class="hljs-string">'Syntax.Error'</span>, <span class="hljs-string">'name allowed to have dot qualifiers in ES6 classes'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-320">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-320">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-321">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-321">&#182;</a>
              </div>
              <p><strong>TODO</strong> Maybe parsing goes here so we can us it to ensure that assert
and the rest set the correct file and line in the stack. That is,
introduce parsing and then use it to get the top of the stack.</p>

            </div>

        </li>


        <li id="section-322">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-322">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-323">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-323">&#182;</a>
              </div>
              <h2 id="assertions">Assertions</h2>

            </div>

        </li>


        <li id="section-324">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-324">&#182;</a>
              </div>
              <p>If you’re using Interrupt in your code would probably like to raise
assertions that are derived from <code>Interrupt</code> instead of using <code>assert</code>
and raising errors that are of type <code>AssertionError</code>.</p>

            </div>

        </li>


        <li id="section-325">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-325">&#182;</a>
              </div>
              <p>Interrupt adds a simple boolean assertion function as a static class
member of the generated <code>Interrupt</code> derived exception class. You can use
this in lieu of the Node.js <code>assert</code> module. The exceptions you raise
will be consistent, the same type, with a code specific to your
application instead of <code>ERR_ASSERTION</code> and you can add properties to your
assertion exceptions.</p>

            </div>

        </li>


        <li id="section-326">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-326">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- Interrupt assertions ---\n'</span>)
    {
        <span class="hljs-keyword">debugger</span>
        <span class="hljs-keyword">const</span> ParseError = Interrupt.create(<span class="hljs-string">'ParseError'</span>, {
            <span class="hljs-attr">NULL_ARGUMENT</span>: <span class="hljs-string">'the JSON string to parse must not be null'</span>,
            <span class="hljs-attr">INVALID_TYPE</span>: <span class="hljs-string">'JSON must be a string, received: %(type)s'</span>,
            <span class="hljs-attr">TOO_MUCH_JSON</span>: <span class="hljs-string">'JSON string must be less than %(MAX_LENGTH)s characters received: %(length)s'</span>,
            <span class="hljs-attr">INVALID_JSON</span>: <span class="hljs-string">'unable to parse JSON string'</span>
        })

        <span class="hljs-keyword">const</span> MAX_LENGTH = <span class="hljs-number">1024</span>

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span> (<span class="hljs-params">json</span>) </span>{
            ParseError.assert(json != <span class="hljs-literal">null</span>, <span class="hljs-string">'NULL_ARGUMENT'</span>)
            ParseError.assert(<span class="hljs-keyword">typeof</span> json == <span class="hljs-string">'string'</span>, <span class="hljs-string">'INVALID_TYPE'</span>, { <span class="hljs-attr">type</span>: <span class="hljs-keyword">typeof</span> json })
            ParseError.assert(json.length &lt; MAX_LENGTH, <span class="hljs-string">'TOO_MUCH_JSON'</span>, { MAX_LENGTH, <span class="hljs-attr">length</span>: json.length })
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(json)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ParseError(<span class="hljs-string">'INVALID_JSON'</span>, error, { json })
            }
        }

        <span class="hljs-keyword">try</span> {
            parse(<span class="hljs-number">1</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.symbol, ParseError.INVALID_TYPE, <span class="hljs-string">'symbol set'</span>)
            okay(error.code, <span class="hljs-string">'INVALID_TYPE'</span>, <span class="hljs-string">'code set'</span>)
            okay(error.type, <span class="hljs-string">'number'</span>, <span class="hljs-string">'type property set'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-327">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-327">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-328">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-328">&#182;</a>
              </div>
              <p>Thie first argument to <code>.assert()</code> is a condition that must be truthy.
After the condition argument the assertion accepts all the of the same
arguments that the exception constructor accepts.</p>

            </div>

        </li>


        <li id="section-329">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-329">&#182;</a>
              </div>
              <p>If the only argument after the assertion is a function it is interpreted
as a <code>callee</code>. It is used as an exception constructor function.</p>

            </div>

        </li>


        <li id="section-330">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-330">&#182;</a>
              </div>
              <p>Sometimes propeties require some calculation so building the properties
argument takes effort, effort that we throw away immediately if the
assertion doesn’t fail.</p>

            </div>

        </li>


        <li id="section-331">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-331">&#182;</a>
              </div>
              <p>This exception constructor function of which we speak can defer that
calculation. It will only be run if the condition fails.</p>

            </div>

        </li>


        <li id="section-332">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-332">&#182;</a>
              </div>
              <p>We can rewrite our contrived example eliminating our contrived
calculations.</p>

            </div>

        </li>


        <li id="section-333">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-333">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- Interrupt assertions with deferred calculation ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> ParseError = Interrupt.create(<span class="hljs-string">'ParseError'</span>, {
            <span class="hljs-attr">NULL_ARGUMENT</span>: <span class="hljs-string">'the JSON string to parse must not be null'</span>,
            <span class="hljs-attr">INVALID_TYPE</span>: <span class="hljs-string">'JSON must be a string, received: %(type)s'</span>,
            <span class="hljs-attr">TOO_MUCH_JSON</span>: <span class="hljs-string">'JSON string must be less than %(MAX_LENGTH)s characters received: %(length)s'</span>,
            <span class="hljs-attr">INVALID_JSON</span>: <span class="hljs-string">'unable to parse JSON string'</span>
        })

        <span class="hljs-keyword">const</span> MAX_LENGTH = <span class="hljs-number">1024</span>

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span> (<span class="hljs-params">json</span>) </span>{
            ParseError.assert(json != <span class="hljs-literal">null</span>, <span class="hljs-string">'NULL_ARGUMENT'</span>)
            ParseError.assert(<span class="hljs-keyword">typeof</span> json == <span class="hljs-string">'string'</span>, $ =&gt; $(<span class="hljs-string">'INVALID_TYPE'</span>, { <span class="hljs-attr">type</span>: <span class="hljs-keyword">typeof</span> json }))
            ParseError.assert(json.length &lt; MAX_LENGTH, $ =&gt; $(<span class="hljs-string">'TOO_MUCH_JSON'</span>, {
                <span class="hljs-attr">MAX_LENGTH</span>: MAX_LENGTH,
                <span class="hljs-attr">length</span>: json.length,
                <span class="hljs-attr">difference</span>: json.length - MAX_LENGTH
            }))
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(json)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ParseError(<span class="hljs-string">'INVALID_JSON'</span>, error, { json })
            }
        }

        <span class="hljs-keyword">try</span> {
            parse(<span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-string">'x'</span>.repeat(<span class="hljs-number">1023</span>)))
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.symbol, ParseError.TOO_MUCH_JSON, <span class="hljs-string">'deferred assert symbol set'</span>)
            okay(error.code, <span class="hljs-string">'TOO_MUCH_JSON'</span>, <span class="hljs-string">'deferred assert code set'</span>)
            okay(error.difference, <span class="hljs-number">1</span>, <span class="hljs-string">'deferred assert property set'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-334">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-334">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-335">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-335">&#182;</a>
              </div>
              <h2 id="synchronous-trycatch-wrappers">Synchronous <code>try</code>/<code>catch</code> Wrappers</h2>

            </div>

        </li>


        <li id="section-336">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-336">&#182;</a>
              </div>
              <p>There are times when I don’t want to go to the trouble of unit testing
catch blocks that merely wrap an exception, but I don’t want to forgo the
unit test coverage.</p>

            </div>

        </li>


        <li id="section-337">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-337">&#182;</a>
              </div>
              <p>When all a catch block does is wrap and rethrow, you can use the static
<code>invoke()</code> method specifying a guarded function to run and the parameters
to the error constructor of the wrapper function if the function fails.
The function will be run in <code>try/catch</code> block and if the function throws
an exception, the error will be wrapped in an exception constructed with
the given constructor parameters.</p>

            </div>

        </li>


        <li id="section-338">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-338">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-keyword">const</span> ParseError = Interrupt.create(<span class="hljs-string">'ParseError'</span>, {
            <span class="hljs-attr">INVALID_JSON</span>: <span class="hljs-string">'unable to parse JSON string'</span>
        })

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span> (<span class="hljs-params">json</span>) </span>{
            <span class="hljs-keyword">return</span> ParseError.invoke(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">JSON</span>.parse(json), <span class="hljs-string">'INVALID_JSON'</span>)
        }

        <span class="hljs-keyword">try</span> {
            parse(<span class="hljs-string">'!'</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.code, <span class="hljs-string">'INVALID_JSON'</span>, <span class="hljs-string">'synchronous try/catch wrapper code set'</span>)
            okay(error.errors[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">SyntaxError</span>, <span class="hljs-string">'synchronous try/catch wrapper nested error present'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-339">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-339">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-340">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-340">&#182;</a>
              </div>
              <p>You cannot use invoke to call <code>async</code> functions or resolve <code>Promise</code>s.
For that you use the static <code>resolve()</code>. See below.</p>

            </div>

        </li>


        <li id="section-341">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-341">&#182;</a>
              </div>
              <p>For consistencies sake, you can defer calculation of the constructor
parameters. If you pass a function as the only argument after the guarded
function is a function it is used as an exception constructor.</p>

            </div>

        </li>


        <li id="section-342">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-342">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-keyword">const</span> ParseError = Interrupt.create(<span class="hljs-string">'ParseError'</span>, {
            <span class="hljs-attr">INVALID_JSON</span>: <span class="hljs-string">'unable to parse JSON string'</span>
        })

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span> (<span class="hljs-params">json</span>) </span>{
            <span class="hljs-keyword">return</span> ParseError.invoke(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">JSON</span>.parse(json), $ =&gt; $(<span class="hljs-string">'INVALID_JSON'</span>, { <span class="hljs-attr">length</span>: json.length }))
        }

        <span class="hljs-keyword">try</span> {
            parse(<span class="hljs-string">'!'</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.code, <span class="hljs-string">'INVALID_JSON'</span>, <span class="hljs-string">'synchronous try/catch wrapper code set'</span>)
            okay(error.length, <span class="hljs-number">1</span>, <span class="hljs-string">'synchronous try/catch wrapper property set'</span>)
            okay(error.errors[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">SyntaxError</span>, <span class="hljs-string">'synchronous try/catch wrapper nested error present'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-343">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-343">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-344">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-344">&#182;</a>
              </div>
              <p><strong>TODO</strong> Didn’t I write about this at length? Is it in the swipe?</p>

            </div>

        </li>


        <li id="section-345">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-345">&#182;</a>
              </div>
              <p><strong>TODO</strong> Okay, look in swipe, but it is not above. This is the beginnning
of the discussion of stack trace preservation. Needs more preamble.</p>

            </div>

        </li>


        <li id="section-346">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-346">&#182;</a>
              </div>
              <p><strong>TODO</strong> Needs to be introduced with callbacks which have no caveats.
Promises are fixed in Node.js 14, so, no wait. Isn’t it broken regardless
if you call a Node.js filesystem function? I believe I decided to do
callbacks first for some reason.</p>

            </div>

        </li>


        <li id="section-347">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-347">&#182;</a>
              </div>
              <p>Often times you invoke system functions that produce stubby contextless
errors like <code>EBADFD</code> stack trace at all. This is an <a href="https://github.com/nodejs/node/issues/30944">known issue in
Node.js</a>.</p>

            </div>

        </li>


        <li id="section-348">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-348">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- file system call with no stack information ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises

        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reader</span> </span>{
            <span class="hljs-keyword">async</span> read (filename) {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> fs.readFile(filename)
            }
        }

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> Reader
            <span class="hljs-keyword">await</span> reader.read(path.join(__dirname, <span class="hljs-string">'missing.txt'</span>))
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-349">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-349">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-350">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-350">&#182;</a>
              </div>
              <p>If you see this error in your production error logs, how are you supposed
to know where in your code it orginates?</p>

            </div>

        </li>


        <li id="section-351">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-351">&#182;</a>
              </div>
              <p>Well, you can wrap the file system call in an application exception.
That’s what we’re here for.</p>

            </div>

        </li>


        <li id="section-352">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-352">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- a try/catch block around a single file system call ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises

        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reader</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Reader.Error'</span>, {
                <span class="hljs-attr">UNABLE_TO_READ_FILE</span>: <span class="hljs-string">'unable to read file: %(filename)s'</span>
            })

            <span class="hljs-keyword">async</span> read (filename) {
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> fs.readFile(filename)
                } <span class="hljs-keyword">catch</span> (error) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Reader.Error(<span class="hljs-string">'UNABLE_TO_READ_FILE'</span>, error, { filename })
                }
            }
        }

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> Reader
            <span class="hljs-keyword">await</span> reader.read(path.join(__dirname, <span class="hljs-string">'missing.txt'</span>))
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.code, <span class="hljs-string">'UNABLE_TO_READ_FILE'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-353">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-353">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-354">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-354">&#182;</a>
              </div>
              <p>However, now you have a catch block you need to unit test. I am fond of
unit test coverage and really don’t trust uncovered catch blocks. I don’t
want to start running untested code just when things are starting to go
sideways.</p>

            </div>

        </li>


        <li id="section-355">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-355">&#182;</a>
              </div>
              <p>If you’re doing work with the file system you’re going to want to wrap a
lot of calls in this fashion, but you’re going to generate a lot of these
catch blocks and then you have to figure out some way to generate errors.
This is particularly difficult with file handles, if you open, read and
close in a single function, you can test a failure to open by deleting
the file, but how do you test close?</p>

            </div>

        </li>


        <li id="section-356">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-356">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- a try/catch block for each of four file system calls ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises

        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reader</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Reader.Error'</span>, {
                <span class="hljs-attr">UNABLE_TO_OPEN_FILE</span>: <span class="hljs-string">'unable to open file %(filename)s'</span>,
                <span class="hljs-attr">UNABLE_TO_READ_FILE</span>: <span class="hljs-string">'unable to read file %(filename)s'</span>,
                <span class="hljs-attr">UNABLE_TO_STAT_FILE</span>: <span class="hljs-string">'unable to stat file %(filename)s'</span>,
                <span class="hljs-attr">UNABLE_TO_CLOSE_FILE</span>: <span class="hljs-string">'unable to close file %(filename)s'</span>
            })

            <span class="hljs-keyword">async</span> read (filename) {</pre></div></div>

        </li>


        <li id="section-357">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-357">&#182;</a>
              </div>
              <p><em>It is not difficult to test this catch block.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">let</span> handle
                <span class="hljs-keyword">try</span> {
                    handle = <span class="hljs-keyword">await</span> fs.open(filename, <span class="hljs-string">'r'</span>)
                } <span class="hljs-keyword">catch</span> (error) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Reader.Error(<span class="hljs-string">'UNABLE_TO_OPEN_FILE'</span>, error, { filename })
                }</pre></div></div>

        </li>


        <li id="section-358">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-358">&#182;</a>
              </div>
              <p><em>But how would you test this one? What sort of file
permission trickery do you have to set up in your unit test
to create a file you can open but you cannot stat? Do you
have to run your tests as root to to do it?</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">let</span> stat
                <span class="hljs-keyword">try</span> {
                    stat = <span class="hljs-keyword">await</span> handle.stat()
                } <span class="hljs-keyword">catch</span> (error) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Reader.Error(<span class="hljs-string">'UNABLE_TO_STAT_FILE'</span>, error, { filename })
                }
                <span class="hljs-keyword">const</span> buffer = Buffer.alloc(stat.size)</pre></div></div>

        </li>


        <li id="section-359">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-359">&#182;</a>
              </div>
              <p><em>How about a file you’ve been allowed to open for reading
that you’re not actually allowed to read?</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">try</span> {
                    <span class="hljs-keyword">await</span> handle.read(buffer, <span class="hljs-number">0</span>, buffer.length, <span class="hljs-number">0</span>)
                } <span class="hljs-keyword">catch</span> (error) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Reader.Error(<span class="hljs-string">'UNABLE_TO_READ_FILE'</span>, error, { filename })
                }</pre></div></div>

        </li>


        <li id="section-360">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-360">&#182;</a>
              </div>
              <p><em>How about a file you’ve been allowed to open for reading
that you’ve stat’d and read that you’re not allowed to
close?</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">try</span> {
                    <span class="hljs-keyword">await</span> handle.close()
                } <span class="hljs-keyword">catch</span> (error) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Reader.Error(<span class="hljs-string">'UNABLE_TO_CLOSE_FILE'</span>, error, { filename })
                }
                <span class="hljs-keyword">return</span> buffer
            }
        }

        <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> Reader

        <span class="hljs-keyword">const</span> source = <span class="hljs-keyword">await</span> reader.read(__filename)
        okay(<span class="hljs-regexp">/hippopotomus/</span>.test(source), <span class="hljs-string">'found hippopotomus in source'</span>)

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> Reader
            <span class="hljs-keyword">await</span> reader.read(path.join(__dirname, <span class="hljs-string">'missing.txt'</span>))
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.code, <span class="hljs-string">'UNABLE_TO_OPEN_FILE'</span>, <span class="hljs-string">'detailed catch blocks'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-361">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-361">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-362">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-362">&#182;</a>
              </div>
              <p>Of course, dear reader you’re now screaming at your screen. Why not wrap
all four operations in a single catch block? That’s what exceptions are
for! That’s how exceptions work!</p>

            </div>

        </li>


        <li id="section-363">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-363">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- a monolithic try/catch block for four file system calls ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises

        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reader</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Reader.Error'</span>, {
                <span class="hljs-attr">UNABLE_TO_READ_FILE</span>: <span class="hljs-string">'unable to read file %(filename)s'</span>
            })

            <span class="hljs-keyword">async</span> read (filename) {
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-keyword">const</span> handle = <span class="hljs-keyword">await</span> fs.open(filename, <span class="hljs-string">'r'</span>)
                    <span class="hljs-keyword">const</span> stat = <span class="hljs-keyword">await</span> handle.stat()
                    <span class="hljs-keyword">const</span> buffer = Buffer.alloc(stat.size)
                    <span class="hljs-keyword">await</span> handle.read(buffer, <span class="hljs-number">0</span>, buffer.length, <span class="hljs-number">0</span>)
                    <span class="hljs-keyword">await</span> handle.close()
                    <span class="hljs-keyword">return</span> buffer
                } <span class="hljs-keyword">catch</span> (error) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Reader.Error(<span class="hljs-string">'UNABLE_TO_READ_FILE'</span>, error, { filename })
                }
            }
        }

        <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> Reader

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> Reader
            <span class="hljs-keyword">await</span> reader.read(path.join(__dirname, <span class="hljs-string">'missing.txt'</span>))
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.code, <span class="hljs-string">'UNABLE_TO_READ_FILE'</span>, <span class="hljs-string">'monolithic catch block'</span>)
        }

        <span class="hljs-keyword">const</span> source = <span class="hljs-keyword">await</span> reader.read(__filename)
        okay(<span class="hljs-regexp">/hippopotomus/</span>.test(source), <span class="hljs-string">'found hippopotomus in source'</span>)
    }</pre></div></div>

        </li>


        <li id="section-364">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-364">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-365">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-365">&#182;</a>
              </div>
              <p>Well, dear reader, yes, that’s how exceptions are <em>supposed</em> to work, and
in other languages like Java where stack traces are maintained you’d know
exactly which file system operation failed, but this is JavaScript. In
this simple example you’ll know the error came from the try block and you
can determine which call failed from the error message thanks to the
context provided by the single catch block, but in a more complicated
try block you have to read through the code to try it, and in ever more
complicatd code there maybe mutliple opens, reads, stats, and closes to
chose from. If you’re trying to match a single stack trace obtained from
one of a hundred machines in production with the file system function
call that generated it, a line number sure is nice.</p>

            </div>

        </li>


        <li id="section-366">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-366">&#182;</a>
              </div>
              <p>And for that we have <code>Interrupt.resolve</code> which resolves a <code>Promise</code> and
wraps the exception if it rejects.</p>

            </div>

        </li>


        <li id="section-367">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-367">&#182;</a>
              </div>
              <p><strong>TODO</strong> Somewhere I should just write a blog post about my coding style,
not to bless the world with my genius (◔_◔) but to just point out that
the stuff I write is <code>async</code>/<code>await</code>, code coverage matters, whatever
else…</p>

            </div>

        </li>


        <li id="section-368">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-368">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- a monolithic try/catch block for four file system calls ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises

        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reader</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Reader.Error'</span>, {
                <span class="hljs-attr">UNABLE_TO_OPEN_FILE</span>: <span class="hljs-string">'unable to open file %(filename)s'</span>,
                <span class="hljs-attr">UNABLE_TO_READ_FILE</span>: <span class="hljs-string">'unable to read file %(filename)s'</span>,
                <span class="hljs-attr">UNABLE_TO_STAT_FILE</span>: <span class="hljs-string">'unable to stat file %(filename)s'</span>,
                <span class="hljs-attr">UNABLE_TO_CLOSE_FILE</span>: <span class="hljs-string">'unable to close file %(filename)s'</span>
            })

            <span class="hljs-keyword">async</span> read (filename) {
                <span class="hljs-keyword">const</span> handle = <span class="hljs-keyword">await</span> Reader.Error.resolve(fs.open(filename, <span class="hljs-string">'r'</span>), $ =&gt; $(<span class="hljs-string">'UNABLE_TO_OPEN_FILE'</span>, { filename }))
                <span class="hljs-keyword">const</span> stat = <span class="hljs-keyword">await</span> Reader.Error.resolve(handle.stat(), <span class="hljs-string">'UNABLE_TO_STAT_FILE'</span>, { filename })
                <span class="hljs-keyword">const</span> buffer = Buffer.alloc(stat.size)
                <span class="hljs-keyword">await</span> Reader.Error.resolve(handle.read(buffer, <span class="hljs-number">0</span>, buffer.length, <span class="hljs-number">0</span>), <span class="hljs-string">'UNABLE_TO_READ_FILE'</span>, { filename })
                <span class="hljs-keyword">await</span> Reader.Error.resolve(handle.close(), <span class="hljs-string">'UNABLE_TO_CLOSE_FILE'</span>, { filename })
                <span class="hljs-keyword">return</span> buffer
            }
        }

        <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> Reader

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> Reader
            <span class="hljs-keyword">await</span> reader.read(path.join(__dirname, <span class="hljs-string">'missing.txt'</span>))
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.code, <span class="hljs-string">'UNABLE_TO_OPEN_FILE'</span>, <span class="hljs-string">'detailed catch blocks'</span>)
        }

        <span class="hljs-keyword">const</span> source = <span class="hljs-keyword">await</span> reader.read(__filename)
        okay(<span class="hljs-regexp">/hippopotomus/</span>.test(source), <span class="hljs-string">'found hippopotomus in source'</span>)
    }</pre></div></div>

        </li>


        <li id="section-369">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-369">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-370">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-370">&#182;</a>
              </div>
              <p>These function invocations will always be verbose, but they don’t have to
be repetitive. If you use some of the same parameters in each call, you
can curry the function. If the first argument is an options object, code
string, code symbol or format message and not a function or <code>Promise</code>
then <code>reslove()</code> will return a function that operates exactly like
<code>resolve()</code> that will construct an exception with those arguments merged
with the arguments of the specific invocation.</p>

            </div>

        </li>


        <li id="section-371">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-371">&#182;</a>
              </div>
              <p><strong>TODO</strong> Tour of <code>options</code> and <code>voptions</code>.</p>

            </div>

        </li>


        <li id="section-372">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-372">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- a monolithic try/catch block for four file system calls ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises

        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reader</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Reader.Error'</span>, {
                <span class="hljs-attr">UNABLE_TO_OPEN_FILE</span>: <span class="hljs-string">'unable to open file %(filename)s'</span>,
                <span class="hljs-attr">UNABLE_TO_READ_FILE</span>: <span class="hljs-string">'unable to read file %(filename)s'</span>,
                <span class="hljs-attr">UNABLE_TO_STAT_FILE</span>: <span class="hljs-string">'unable to stat file %(filename)s'</span>,
                <span class="hljs-attr">UNABLE_TO_CLOSE_FILE</span>: <span class="hljs-string">'unable to close file %(filename)s'</span>
            })

            <span class="hljs-keyword">async</span> read (filename) {
                <span class="hljs-keyword">const</span> resolver = Reader.Error.resolve({}, { filename })
                <span class="hljs-keyword">const</span> handle = <span class="hljs-keyword">await</span> resolver(fs.open(filename, <span class="hljs-string">'r'</span>), $ =&gt; $(<span class="hljs-string">'UNABLE_TO_OPEN_FILE'</span>))
                <span class="hljs-keyword">const</span> stat = <span class="hljs-keyword">await</span> resolver(handle.stat(), $ =&gt; $(<span class="hljs-string">'UNABLE_TO_STAT_FILE'</span>))
                <span class="hljs-keyword">const</span> buffer = Buffer.alloc(stat.size)
                <span class="hljs-keyword">await</span> resolver(handle.read(buffer, <span class="hljs-number">0</span>, buffer.length, <span class="hljs-number">0</span>), $ =&gt; $(<span class="hljs-string">'UNABLE_TO_READ_FILE'</span>))
                <span class="hljs-keyword">await</span> resolver(handle.close(), $ =&gt; $(<span class="hljs-string">'UNABLE_TO_CLOSE_FILE'</span>))
                <span class="hljs-keyword">return</span> buffer
            }
        }

        <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> Reader

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> Reader
            <span class="hljs-keyword">await</span> reader.read(path.join(__dirname, <span class="hljs-string">'missing.txt'</span>))
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.code, <span class="hljs-string">'UNABLE_TO_OPEN_FILE'</span>, <span class="hljs-string">'detailed catch blocks'</span>)
        }

        <span class="hljs-keyword">const</span> source = <span class="hljs-keyword">await</span> reader.read(__filename)
        okay(<span class="hljs-regexp">/hippopotomus/</span>.test(source), <span class="hljs-string">'found hippopotomus in source'</span>)
    }</pre></div></div>

        </li>


        <li id="section-373">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-373">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-374">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-374">&#182;</a>
              </div>
              <p>Since Node.js 14 there stack traces are traced across <code>Promise</code>
resolutions (the microtask queue) but are still lost when entering the
Node.js event loop (the macrostask queue.) If your application is
targeted for Node.js 14 and above then you do not have to use the
deferred constructor to receive a stack trace that includes the
application file and line.</p>

            </div>

        </li>


        <li id="section-375">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-375">&#182;</a>
              </div>
              <p><strong>TODO</strong> No, talk about Node.js 12 versus 14 with the existing examples,
do not repeat them or refer back to them.</p>

            </div>

        </li>


        <li id="section-376">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-376">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-comment">/* and that example would go here, and `sprintf` is decided */</span>
    }</pre></div></div>

        </li>


        <li id="section-377">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-377">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-378">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-378">&#182;</a>
              </div>
              <p>Error-first callback style programming continues to lose stack traces
even in the latest versions of Node.js. The call stack originates from
the Node.js event loop and usually terminates in the Node.js core
libraries or some dependent module. If you wrap the exception you will
get a stack that will at least include your callback so with wrapping you
can usually figure out the asynchronous call resulted in the error.</p>

            </div>

        </li>


        <li id="section-379">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-379">&#182;</a>
              </div>
              <p>You can use one of the many long stack trace modules on NPM to get a full
stack trace but these are monkey patched modules that break frequently.
They also generate a stack trace for each asynchronous call in order to
preserve the call stack. This is an expensive operation and these modules
discourage their own use in production. <strong>TODO</strong> Out of order.</p>

            </div>

        </li>


        <li id="section-380">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-380">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)

        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reader</span> </span>{</pre></div></div>

        </li>


        <li id="section-381">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-381">&#182;</a>
              </div>
              <p><strong>TODO</strong> <code>sprintf</code> is rasing exceptions ‘%{‘ makes it angry,
catch any exception it might throw and just use the string.</p>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Reader.Error'</span>, {
                <span class="hljs-attr">UNABLE_TO_READ_FILE</span>: <span class="hljs-string">'unable to read file %(filename)s'</span>
            })

            <span class="hljs-keyword">async</span> read (filename, callback) {
                fs.readFile(filename, (error, body) =&gt; {
                    <span class="hljs-keyword">if</span> (error) {
                        callback(<span class="hljs-keyword">new</span> Reader.Error(<span class="hljs-string">'UNABLE_TO_READ_FILE'</span>, error, { filename }))
                    } <span class="hljs-keyword">else</span> {
                        callback(<span class="hljs-literal">null</span>, body)
                    }
                })
            }
        }

        <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> Reader

        reader.read(path.join(__dirname, <span class="hljs-string">'missing.txt'</span>), (error, body) =&gt; {
            <span class="hljs-keyword">if</span> (error) {
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/hippopotomus/</span>.test(body.toString()))
            }
            resolve()
        })
    })</pre></div></div>

        </li>


        <li id="section-382">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-382">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-383">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-383">&#182;</a>
              </div>
              <p>Wrapping exceptions in this mannor can create a lot of additional
anonymous callbacks that exist only to wrap the callback. These become
difficult to unit test with complete coverage. We can create a helper
function that can perform the wrapping, unit test the wrapper separately,
eliminating these little branches throughout our code.</p>

            </div>

        </li>


        <li id="section-384">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-384">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrap</span> (<span class="hljs-params">callback, message, properties</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...vargs</span>) </span>{
                <span class="hljs-keyword">if</span> (vargs[<span class="hljs-number">0</span>] != <span class="hljs-literal">null</span>) {
                    callback(<span class="hljs-keyword">new</span> Reader.Error(message, vargs[<span class="hljs-number">0</span>], properties))
                } <span class="hljs-keyword">else</span> {
                    callback.apply(<span class="hljs-literal">null</span>, vargs)
                }
            }
        }

        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reader</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Reader.Error'</span>, {
                <span class="hljs-attr">UNABLE_TO_READ_FILE</span>: <span class="hljs-string">'unable to read file %(filename)s'</span>
            })

            <span class="hljs-keyword">async</span> read (filename, callback) {
                fs.readFile(filename, wrap(callback, <span class="hljs-string">'UNABLE_TO_READ_FILE'</span>, { filename }))
            }
        }

        <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> Reader

        reader.read(path.join(__dirname, <span class="hljs-string">'missing.txt'</span>), (error, body) =&gt; {
            <span class="hljs-keyword">if</span> (error) {
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
                okay(error.code, <span class="hljs-string">'UNABLE_TO_READ_FILE'</span>, <span class="hljs-string">'code set'</span>)
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/hippopotomus/</span>.test(body.toString()))
            }
            resolve()
        })
    })</pre></div></div>

        </li>


        <li id="section-385">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-385">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-386">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-386">&#182;</a>
              </div>
              <p>But now the originating application file and line number are missing from
our stack trace. Our stack trace will pass through our wrapper function,
not through the function that called the wrap function. That call has
already returned. In order to poke back into the function that called the
wrapper function we use an error constructor callback. It will poke back
inot the function that called the wrapper function, ususally at the file
and line (but not the character position) where the wrapper was called.</p>

            </div>

        </li>


        <li id="section-387">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-387">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">encase</span> (<span class="hljs-params">callback, message, properties</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...vargs</span>) </span>{
                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">constructor</span> (<span class="hljs-params">message</span>) </span>{
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Reader.Error({ <span class="hljs-string">'#callee'</span>: <span class="hljs-keyword">constructor</span> }, message, vargs[0], properties)
                }
                if (vargs[0] != null) {
                    callback(message(<span class="hljs-keyword">constructor</span>))
                } else {
                    callback.apply(<span class="hljs-literal">null</span>, vargs)
                }
            }
        }

        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reader</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Reader.Error'</span>, {
                <span class="hljs-attr">UNABLE_TO_READ_FILE</span>: <span class="hljs-string">'unable to read file %(filename)s'</span>
            })

            <span class="hljs-keyword">async</span> read (filename, callback) {
                fs.readFile(filename, encase(callback, $ =&gt; $(<span class="hljs-string">'UNABLE_TO_READ_FILE'</span>, { filename })))
            }
        }

        <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> Reader
        reader.read(path.join(__dirname, <span class="hljs-string">'missing.txt'</span>), (error, body) =&gt; {
            <span class="hljs-keyword">if</span> (error) {
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/hippopotomus/</span>.test(body.toString()))
            }
            resolve()
        })
    })</pre></div></div>

        </li>


        <li id="section-388">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-388">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-389">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-389">&#182;</a>
              </div>
              <p>This is how we get an useful stack trace without using long stack traces
modules. It is useful because it contains a file and line number from our
application that directly references where the asynchronous call
originated.</p>

            </div>

        </li>


        <li id="section-390">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-390">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)

        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reader</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Reader.Error'</span>, {
                <span class="hljs-attr">UNABLE_TO_READ_FILE</span>: <span class="hljs-string">'unable to read file %(filename)s'</span>
            })

            <span class="hljs-keyword">async</span> read (filename, callback) {
                fs.readFile(filename, Reader.Error.callback(<span class="hljs-function"><span class="hljs-params">$</span> =&gt;</span> $(<span class="hljs-string">'UNABLE_TO_READ_FILE'</span>, { filename }), callback))
            }
        }

        <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> Reader

        reader.read(path.join(__dirname, <span class="hljs-string">'missing.txt'</span>), (error, body) =&gt; {
            <span class="hljs-keyword">if</span> (error) {
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
                okay(error.code, <span class="hljs-string">'UNABLE_TO_READ_FILE'</span>, <span class="hljs-string">'code set'</span>)
                okay(error.errors[<span class="hljs-number">0</span>].code, <span class="hljs-string">'ENOENT'</span>, <span class="hljs-string">'nested code set'</span>)
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/hippopotomus/</span>.test(body.toString()))
            }
            resolve()
        })
    })</pre></div></div>

        </li>


        <li id="section-391">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-391">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-392">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-392">&#182;</a>
              </div>
              <p>The stack trace is useful but incomplete, it is not a full stack trace.
If we repeat the wrapper process for each asynchronous call, however, it
gets to be more complete, but not contiguous.</p>

            </div>

        </li>


        <li id="section-393">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-393">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)

        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reader</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Reader.Error'</span>, {
                <span class="hljs-attr">UNABLE_TO_READ_FILE</span>: <span class="hljs-string">'unable to read file %(filename)s'</span>
            })

            <span class="hljs-keyword">async</span> read (filename, callback) {
                fs.readFile(filename, Reader.Error.callback(<span class="hljs-function"><span class="hljs-params">$</span> =&gt;</span> $(<span class="hljs-string">'UNABLE_TO_READ_FILE'</span>, { filename }), callback))
            }

            <span class="hljs-keyword">async</span> load (filename, callback) {
                <span class="hljs-keyword">this</span>.read(filename, Reader.Error.callback(<span class="hljs-function"><span class="hljs-params">$</span> =&gt;</span> $(<span class="hljs-string">'UNABLE_TO_READ_FILE'</span>, { filename }), (error, body) =&gt; {
                    <span class="hljs-keyword">if</span> (error) {
                        callback(error)
                    } <span class="hljs-keyword">else</span> {
                        callback(<span class="hljs-built_in">JSON</span>.parse(body.toString()))
                    }
                }))
            }
        }

        <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> Reader

        reader.load(path.join(__dirname, <span class="hljs-string">'missing.txt'</span>), (error, body) =&gt; {
            <span class="hljs-keyword">if</span> (error) {
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/hippopotomus/</span>.test(body.toString()))
            }
            resolve()
        })
    })</pre></div></div>

        </li>


        <li id="section-394">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-394">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-395">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-395">&#182;</a>
              </div>
              <h2 id="currying">Currying</h2>

            </div>

        </li>


        <li id="section-396">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-396">&#182;</a>
              </div>
              <ul>
<li>Start with resolve, callback, invoke, then assert.</li>
</ul>

            </div>

        </li>


        <li id="section-397">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-397">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)

        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reader</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Reader.Error'</span>, {
                <span class="hljs-attr">UNABLE_TO_READ_DIRECTORY</span>: <span class="hljs-string">'unable to read directory: %(dirname)s'</span>,
                <span class="hljs-attr">UNABLE_TO_READ_FILE</span>: <span class="hljs-string">'unable to read file: %(filename)s'</span>
            })

            <span class="hljs-keyword">async</span> read (dirname, callback) {
                <span class="hljs-keyword">const</span> wrap = Reader.Error.callback({}, { dirname }), files = []
                fs.readdir(dirname, wrap(<span class="hljs-function"><span class="hljs-params">$</span> =&gt;</span> $(<span class="hljs-string">'UNABLE_TO_READ_DIRECTORY'</span>), (error, dir) =&gt; {
                    <span class="hljs-keyword">if</span> (error) {
                        callback(error)
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readFile</span> (<span class="hljs-params"></span>) </span>{
                            <span class="hljs-keyword">if</span> (dir.length == <span class="hljs-number">0</span>) {
                                callback(<span class="hljs-literal">null</span>, files)
                            } <span class="hljs-keyword">else</span> {
                                <span class="hljs-keyword">const</span> filename = path.join(dirname, dir.shift())
                                fs.readFile(filename, <span class="hljs-string">'utf8'</span>, wrap(<span class="hljs-function"><span class="hljs-params">$</span> =&gt;</span> $(<span class="hljs-string">'UNABLE_TO_READ_FILE'</span>, { filename }), (error, body) =&gt; {
                                    <span class="hljs-keyword">if</span> (error) {
                                        callback(error)
                                    } <span class="hljs-keyword">else</span> {
                                        files.push({ filename, body })
                                        readFile()
                                    }
                                }))
                            }
                        }
                        readFile()
                    }
                }))
            }
        }

        <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> Reader

        reader.read(path.join(__dirname, <span class="hljs-string">'missing'</span>), (error, body) =&gt; {
            <span class="hljs-keyword">if</span> (error) {
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
                okay(error.code, <span class="hljs-string">'UNABLE_TO_READ_DIRECTORY'</span>, <span class="hljs-string">'curried callback wrapper code set'</span>)
                okay(error.errors[<span class="hljs-number">0</span>].code, <span class="hljs-string">'ENOENT'</span>, <span class="hljs-string">'curried callback nested error set'</span>)
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/hippopotomus/</span>.test(body.toString()))
            }
            reader.read(path.join(__dirname, <span class="hljs-string">'tmp'</span>, <span class="hljs-string">'eisdir'</span>), (error, body) =&gt; {
                <span class="hljs-keyword">if</span> (error) {
                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
                    okay(error.code, <span class="hljs-string">'UNABLE_TO_READ_FILE'</span>, <span class="hljs-string">'curried callback wrapper code set'</span>)
                    okay(error.errors[<span class="hljs-number">0</span>].code, <span class="hljs-string">'EISDIR'</span>, <span class="hljs-string">'curried callback nested error set'</span>)
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-built_in">console</span>.log(<span class="hljs-regexp">/hippopotomus/</span>.test(body.toString()))
                }
                resolve()
            })
        })
    })</pre></div></div>

        </li>


        <li id="section-398">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-398">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-399">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-399">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-keyword">const</span> ConfigError = Interrupt.create(<span class="hljs-string">'ConfigError'</span>, {
            <span class="hljs-attr">CONFIG_PARSE_ERROR</span>: <span class="hljs-string">'unable to parse config JSON'</span>,
            <span class="hljs-attr">CONFIG_PARAM_MISSING_ERROR</span>: <span class="hljs-string">'parameter is missing: %(param)s'</span>
        })

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseConfig</span> (<span class="hljs-params">config</span>) </span>{
            <span class="hljs-keyword">const</span> invoker = ConfigError.invoke({}, { config })
            <span class="hljs-keyword">const</span> object = invoker(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">JSON</span>.parse(config), <span class="hljs-string">'CONFIG_PARSE_ERROR'</span>)
            <span class="hljs-keyword">return</span> invoker(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> object.settings.volume, <span class="hljs-string">'CONFIG_PARAM_MISSING_ERROR'</span>, { <span class="hljs-attr">param</span>: <span class="hljs-string">'settings.volume'</span> })
        }

        <span class="hljs-keyword">try</span> {
            parseConfig(<span class="hljs-string">'!'</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.code, <span class="hljs-string">'CONFIG_PARSE_ERROR'</span>, <span class="hljs-string">'curried invoke code set'</span>)
            okay(error.errors[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">SyntaxError</span>, <span class="hljs-string">'curried invoke nested error set'</span>)
        }

        <span class="hljs-keyword">try</span> {
            parseConfig(<span class="hljs-string">'{}'</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.code, <span class="hljs-string">'CONFIG_PARAM_MISSING_ERROR'</span>, <span class="hljs-string">'curried invoke code set'</span>)
            okay(error.errors[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">TypeError</span>, <span class="hljs-string">'curried invoke nested error set'</span>)
        }

        okay(parseConfig(<span class="hljs-string">'{"settings":{"volume":0}}'</span>), <span class="hljs-number">0</span>, <span class="hljs-string">'curried invoke no errors'</span>)
    }</pre></div></div>

        </li>


        <li id="section-400">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-400">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-401">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-401">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-keyword">const</span> ConfigError = Interrupt.create(<span class="hljs-string">'ConfigError'</span>, {
            <span class="hljs-attr">CONFIG_PARAM_MISSING_ERROR</span>: <span class="hljs-string">'parameter is missing: %(param)s'</span>
        })

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseConfig</span> (<span class="hljs-params">config</span>) </span>{
            <span class="hljs-keyword">const</span> object = <span class="hljs-built_in">JSON</span>.parse(config)
            <span class="hljs-keyword">const</span> assert = ConfigError.assert(Interrupt.CURRY, { <span class="hljs-attr">config</span>: object })
            assert(object.settings != <span class="hljs-literal">null</span>, <span class="hljs-string">'CONFIG_PARAM_MISSING_ERROR'</span>, { <span class="hljs-attr">param</span>: <span class="hljs-string">'settings'</span> })
            assert(object.settings.volume != <span class="hljs-literal">null</span>, <span class="hljs-string">'CONFIG_PARAM_MISSING_ERROR'</span>, { <span class="hljs-attr">param</span>: <span class="hljs-string">'settings.volume'</span> })
            <span class="hljs-keyword">return</span> object
        }

        <span class="hljs-keyword">try</span> {
            parseConfig(<span class="hljs-string">'{}'</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.code, <span class="hljs-string">'CONFIG_PARAM_MISSING_ERROR'</span>, <span class="hljs-string">'curried assert code set'</span>)
        }

        <span class="hljs-keyword">try</span> {
            parseConfig(<span class="hljs-string">'{"settings":{}}'</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(error.code, <span class="hljs-string">'CONFIG_PARAM_MISSING_ERROR'</span>, <span class="hljs-string">'curried assert code set'</span>)
        }

        okay(parseConfig(<span class="hljs-string">'{"settings":{"volume":0}}'</span>), {
            <span class="hljs-attr">settings</span>: { <span class="hljs-attr">volume</span>: <span class="hljs-number">0</span> }
        }, <span class="hljs-string">'curried assert no failed assertions'</span>)
    }</pre></div></div>

        </li>


        <li id="section-402">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-402">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-403">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-403">&#182;</a>
              </div>
              <h2 id="auditing-deferred-construction">Auditing Deferred Construction</h2>

            </div>

        </li>


        <li id="section-404">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-404">&#182;</a>
              </div>
              <p>Deferred construction is cute when working with asssertions and necessary
for meaninful stack traces when working with callbacks. However, it
creates a lot of little functions that are only invoked if an exception
is raised. These are essentially our catch blocks.</p>

            </div>

        </li>


        <li id="section-405">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-405">&#182;</a>
              </div>
              <p>Even without deferred construction we won’t know if we’ve correctly
created the exception without raising it. Perhaps a property using in the
formatted message is missing, we’ll end up with a poorly formatted
message and missing context in our crash log. It might mean the
difference between fixing a production bug or merely fixing a bug in a
production bug.</p>

            </div>

        </li>


        <li id="section-406">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-406">&#182;</a>
              </div>
              <p>To determine if our exceptions are going to be correctly constructed we
can using the deferred construction audit mechanism. Simply assign a
function to the <code>Interrupt.audit</code> property. If the <code>Interrupt.audit</code>
property is set with a function that function will be called from all the
assistant functions, <code>assert</code>, <code>invoke</code>, <code>callback</code> and <code>resolve</code> with
the constructed exception regardless of whether or not the exception was
necessary. The <code>audit</code> function can examine the constructed exception to
ensure that it’s properties and format are correct.</p>

            </div>

        </li>


        <li id="section-407">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-407">&#182;</a>
              </div>
              <p>Additionally, an <code>errors</code> array is provided. This contains an array of
errors or potential errors encountered while constructing the exception.
These are simple objects, not instances of type <code>Error</code> so they do not
contain a stack trace.</p>

            </div>

        </li>


        <li id="section-408">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-408">&#182;</a>
              </div>
              <p>The <code>invoke</code>, <code>callback</code> and <code>resolve</code> functions wrap an exception.
Exceptions creates soely for the purpose of auditing that are not the
result of a caught exception will use <code>Interrupt.AUDIT</code> for the
exception. This is a <code>Error</code> generated at startup and its stack trace is
meaningless.</p>

            </div>

        </li>


        <li id="section-409">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-409">&#182;</a>
              </div>
              <p>You should only use the audit function in your unit testing.</p>

            </div>

        </li>


        <li id="section-410">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-410">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
        <span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).promises
        <span class="hljs-keyword">const</span> fileSystem = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)

        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Config.Error'</span>, {
                <span class="hljs-attr">INVALID_FILE</span>: <span class="hljs-string">'unable to load file: %(filename)'</span>,
                <span class="hljs-attr">INVALID_ARGUMENT</span>: <span class="hljs-string">'the JSON string to parse must not be null'</span>,
                <span class="hljs-attr">INVALID_JSON</span>: <span class="hljs-string">'unable to parse JSON'</span>
            })

            parse (json) {
                Config.Error.assert(json != <span class="hljs-literal">null</span>, <span class="hljs-string">'INVALID_ARGUMENT'</span>)
                <span class="hljs-keyword">const</span> object = Config.Error.invoke(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">JSON</span>.parse(json), <span class="hljs-string">'INVALID_JSON'</span>)
                <span class="hljs-keyword">return</span> object
            }

            <span class="hljs-keyword">async</span> load (filename) {
                <span class="hljs-keyword">const</span> json = <span class="hljs-keyword">await</span> Config.Error.resolve(fs.readFile(filename, <span class="hljs-string">'utf8'</span>), <span class="hljs-string">'INVALID_FILE'</span>, { filename })
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parse(json)
            }

            classicLoad (filename, callback) {
                fileSystem.readFile(filename, <span class="hljs-string">'utf8'</span>, Config.Error.callback(<span class="hljs-function"><span class="hljs-params">$</span> =&gt;</span> <span class="hljs-function">(<span class="hljs-params"><span class="hljs-string">'INVALID_FILE'</span>, { filename }</span>), (<span class="hljs-params">error, json</span>) =&gt;</span> {
                    <span class="hljs-keyword">if</span> (error) {
                        callback(error)
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">try</span> {
                            callback(<span class="hljs-literal">null</span>, <span class="hljs-keyword">this</span>.parse(json))
                        } <span class="hljs-keyword">catch</span> (error) {
                            callback(error)
                        }
                    }
                }))
            }
        }

        <span class="hljs-keyword">const</span> audit = []

        Interrupt.audit = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, errors</span>) </span>{
            <span class="hljs-keyword">if</span> (error <span class="hljs-keyword">instanceof</span> Config.Error) {
                audit.push({ error, errors })
            }
        }

        <span class="hljs-keyword">const</span> filename = path.join(__dirname, <span class="hljs-string">'tmp'</span>, <span class="hljs-string">'good'</span>, <span class="hljs-string">'config.json'</span>)

        <span class="hljs-keyword">const</span> config = <span class="hljs-keyword">new</span> Config

        okay(<span class="hljs-keyword">await</span> config.load(filename), { <span class="hljs-attr">settings</span>: { <span class="hljs-attr">volume</span>: <span class="hljs-number">0</span> } }, <span class="hljs-string">'audit `Promise` resolution'</span>)

        <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
            config.classicLoad(filename, (error, config) =&gt; {
                <span class="hljs-keyword">if</span> (error) {
                    reject(error)
                } <span class="hljs-keyword">else</span> {
                    okay(config, { <span class="hljs-attr">settings</span>: { <span class="hljs-attr">volume</span>: <span class="hljs-number">0</span> } }, <span class="hljs-string">'audit error-first callback'</span>)
                    resolve()
                }
            })
        })

        okay(audit.length != <span class="hljs-number">0</span>, <span class="hljs-string">'created and reported despite no exceptions raised'</span>)

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> { error, errors } <span class="hljs-keyword">of</span> audit) {
            <span class="hljs-keyword">if</span> (errors.length != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">console</span>.log(errors)
            }
        }</pre></div></div>

        </li>


        <li id="section-411">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-411">&#182;</a>
              </div>
              <p><em>Reset our logging mechamism.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>        audit.length = <span class="hljs-number">0</span></pre></div></div>

        </li>


        <li id="section-412">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-412">&#182;</a>
              </div>
              <p><em>Turn audit off.</em></p>

            </div>

            <div class="content"><div class='highlight'><pre>        Interrupt.audit = <span class="hljs-literal">null</span>

        config.parse(<span class="hljs-string">'{}'</span>)

        okay(audit.length, <span class="hljs-number">0</span>, <span class="hljs-string">'nothing to report'</span>)
    }</pre></div></div>

        </li>


        <li id="section-413">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-413">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-414">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-414">&#182;</a>
              </div>
              <h2 id="reducing-the-verbosity-of-stack-traces">Reducing the Verbosity of Stack Traces</h2>

            </div>

        </li>


        <li id="section-415">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-415">&#182;</a>
              </div>
              <p><strong>TODO</strong> Dedup goes here.</p>

            </div>

        </li>


        <li id="section-416">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-416">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-keyword">const</span> Test = {
            <span class="hljs-attr">Error</span>: Interrupt.create(<span class="hljs-string">'Test.Error'</span>, {
                <span class="hljs-attr">one</span>: <span class="hljs-string">'one'</span>,
                <span class="hljs-attr">two</span>: <span class="hljs-string">'two'</span>,
                <span class="hljs-attr">root</span>: <span class="hljs-string">'root'</span>
            })
        }
        <span class="hljs-keyword">const</span> hello = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'hello'</span>)
        <span class="hljs-keyword">const</span> world = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'world'</span>)
        <span class="hljs-keyword">const</span> one = <span class="hljs-keyword">new</span> Test.Error(<span class="hljs-string">'one'</span>, [ hello, hello, hello ], { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">x</span>: <span class="hljs-number">4</span> })
        <span class="hljs-keyword">const</span> two = <span class="hljs-keyword">new</span> Test.Error(<span class="hljs-string">'one'</span>, [ world, world ], { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">x</span>: <span class="hljs-number">5</span> })
        <span class="hljs-keyword">const</span> three = <span class="hljs-keyword">new</span> Test.Error(<span class="hljs-string">'one'</span>, [ hello, world ], { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">x</span>: <span class="hljs-number">6</span> })
        <span class="hljs-keyword">const</span> four = <span class="hljs-keyword">new</span> Test.Error(<span class="hljs-string">'two'</span>, [ hello, world ], { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">x</span>: <span class="hljs-number">7</span> })
        <span class="hljs-keyword">const</span> interrupt = <span class="hljs-keyword">new</span> Test.Error(<span class="hljs-string">'three'</span>)
        <span class="hljs-keyword">const</span> error = <span class="hljs-keyword">new</span> Test.Error(<span class="hljs-string">'root'</span>, [
            one, one, two, two, three, four, <span class="hljs-keyword">new</span> Test.Error,
            interrupt, interrupt,
            <span class="hljs-keyword">new</span> Test.Error(<span class="hljs-string">'no context'</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>), <span class="hljs-number">1</span>
        ], { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">x</span>: <span class="hljs-number">8</span> })
        <span class="hljs-built_in">console</span>.log(error.stack)
        <span class="hljs-built_in">console</span>.log(Interrupt.dedup(error))
        <span class="hljs-built_in">console</span>.log(Interrupt.dedup(error, error =&gt; {
            <span class="hljs-keyword">return</span> [ error.name, error.code || error.message, error.id || <span class="hljs-literal">null</span> ]
        }))
        <span class="hljs-built_in">console</span>.log(Interrupt.dedup(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>))
    }</pre></div></div>

        </li>


        <li id="section-417">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-417">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-418">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-418">&#182;</a>
              </div>
              <p>Putting this here for test coverage. What needs to be covered? Where is
the dead code? <strong>TODO</strong> Move to <code>swipe.t.js</code>.</p>

            </div>

        </li>


        <li id="section-419">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-419">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Config.Error'</span>, {
                <span class="hljs-attr">FILE_READ_ERROR</span>: <span class="hljs-string">'unable to read file'</span>,
                <span class="hljs-attr">MISSING_CODE_ERROR</span>: <span class="hljs-literal">null</span>
            })
        }

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Config.Error(<span class="hljs-string">'MISSING_CODE_ERROR'</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'&gt;&gt;&gt;'</span>, error.stack, <span class="hljs-string">'!'</span>)
        }

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Config.Error(<span class="hljs-string">'message'</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(error)
        }

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'message'</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(error)
        }</pre></div></div>

        </li>


        <li id="section-420">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-420">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-421">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-421">&#182;</a>
              </div>
              <p><strong>TODO</strong> Multi-line messages. We can still parse them if we indent.
The indent escapes a lot of stuff. If you don’t like our formatting,
that’s fine, your stuff can look bad, we don’t care.</p>

            </div>

        </li>


        <li id="section-422">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-422">&#182;</a>
              </div>
              <p><strong>TODO</strong> We really need to bring parse into <code>readme.t.js</code>. We should
probably be using it through out, we should probably have an error
extraction stream, or at least a buffer parser.</p>

            </div>

        </li>


        <li id="section-423">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-423">&#182;</a>
              </div>
              <p>But, yes, if something is an Error, you can format a message such
that it cannot be parsed. The only thing we could do is check the
type at serialzation time and assert that it is as expected. That the
message is not multi-line, and if it is, that it does not begin with
<code>at</code> at any point. I suppose that is the only condition that
would make it unparsable. If it is unparsable, then we can display it
as JSON.</p>

            </div>

        </li>


        <li id="section-424">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-424">&#182;</a>
              </div>
              <p>We are always going to have <code>cause:</code> and we can put a type specifier
right after that colon, no type specifier means parsable error.</p>

            </div>

        </li>


        <li id="section-425">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-425">&#182;</a>
              </div>
              <p>Still no good place to put the internal errors, except maybe an
<code>errors</code> section, we might have to say <code>constructor:</code> or something
because the word error can be in all the error codes.</p>

            </div>

        </li>


        <li id="section-426">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-426">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'multi-line\nmessage\n    at'</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
        }

        <span class="hljs-keyword">try</span> {
        } <span class="hljs-keyword">catch</span> (error) {
        }

        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-keyword">new</span> Config.Error(<span class="hljs-string">'FILE_READ_ERROR'</span>, { <span class="hljs-attr">key</span>: <span class="hljs-number">1</span> }), <span class="hljs-literal">null</span>, <span class="hljs-number">4</span>))
        <span class="hljs-built_in">console</span>.log(Interrupt.JSON.stringify(<span class="hljs-keyword">new</span> Config.Error(<span class="hljs-string">'FILE_READ_ERROR'</span>, { <span class="hljs-attr">key</span>: <span class="hljs-number">1</span> }), <span class="hljs-literal">null</span>, <span class="hljs-number">4</span>))</pre></div></div>

        </li>


        <li id="section-427">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-427">&#182;</a>
              </div>
              <p><strong>TODO</strong> Wondering if you get an unresolved exception of promise 0
does a <code>setTimeout</code> and promise 1 throws an exception synchronously.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_gather</span> (<span class="hljs-params">callee, promises, options, vargs</span>) </span>{
            <span class="hljs-keyword">const</span> errors = [], results = []
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> promise <span class="hljs-keyword">of</span> promises) {
                <span class="hljs-keyword">try</span> {
                    results.push(<span class="hljs-keyword">await</span> promise)
                } <span class="hljs-keyword">catch</span> (error) {
                    errors.push(error)
                }
            }</pre></div></div>

        </li>


        <li id="section-428">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-428">&#182;</a>
              </div>
              <p><strong>TODO</strong> Some reason why you’d want to allow properties before
the constructor occurred to me but I forgot it.</p>
<p>Expose construct.</p>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (errors.length) {
                <span class="hljs-keyword">throw</span> Interrupt.construct(options, vargs, errors, callee)
            }
            <span class="hljs-keyword">return</span> results
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_all</span> (<span class="hljs-params">callee, options, vargs</span>) </span>{
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(vargs[<span class="hljs-number">0</span>])) {
                <span class="hljs-keyword">return</span> _gather(called, vargs.shift(), options, vargs)
            }
            <span class="hljs-keyword">const</span> merged = Interrupt._options([ options ], vargs)
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">all</span> (<span class="hljs-params">promises, ...vargs</span>) </span>{
                <span class="hljs-keyword">return</span> _all(all, merged, vargs)
            }
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">all</span> (<span class="hljs-params">...vargs</span>) </span>{
            <span class="hljs-keyword">return</span> _all(all, {}, vargs)
        }</pre></div></div>

        </li>


        <li id="section-429">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-429">&#182;</a>
              </div>
              <p><strong>TODO</strong> An <code>assertEqual</code> function would be a good tour of the
currying issues.</p>

            </div>

            <div class="content"><div class='highlight'><pre>
        <span class="hljs-keyword">const</span> one = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'one'</span>)
        <span class="hljs-keyword">const</span> two = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'two'</span>)

        <span class="hljs-keyword">const</span> error = <span class="hljs-keyword">new</span> Config.Error(<span class="hljs-string">'FILE_READ_ERROR'</span>)

        <span class="hljs-built_in">console</span>.log(Interrupt.stringify(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>))
        <span class="hljs-built_in">console</span>.log(Interrupt.stringify(one))
        <span class="hljs-built_in">console</span>.log(Interrupt.explode(one))
        <span class="hljs-built_in">console</span>.log(Interrupt.explode(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>))
        one.code = <span class="hljs-string">'ERROR'</span>
        <span class="hljs-built_in">console</span>.log(Interrupt.explode(one))
        <span class="hljs-keyword">const</span> parser = <span class="hljs-keyword">new</span> Interrupt.Parser
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> line <span class="hljs-keyword">of</span> error.stack.split(<span class="hljs-string">'\n'</span>)) {
            parser.push(line)
        }
        parser.end()
        <span class="hljs-built_in">console</span>.log(parser._node)
        <span class="hljs-comment">/*
        await all([ async () =&gt; {
            await new Promise(resolve =&gt; setTimeout(resolve, 50))
        }, Promise.reject(new Error('thrown')) ], 'wrapped')
        */</span>
    }</pre></div></div>

        </li>


        <li id="section-430">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-430">&#182;</a>
              </div>
              <h2 id="parsing-stack-traces">Parsing Stack Traces</h2>

            </div>

        </li>


        <li id="section-431">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-431">&#182;</a>
              </div>
              <p>The stack trace emitted from an Interrupt generated error is both human
readable and machine readable. Using the <code>Interrupt.parse()</code> method you
can parse the stack trace of an <code>Interrupt</code> error.</p>

            </div>

        </li>


        <li id="section-432">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-432">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- parse an Interrupt stack trace ---\n'</span>)
    {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)

        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Config.Error'</span>, {
                <span class="hljs-string">'FILE_READ_ERROR'</span>: <span class="hljs-string">'unable to read file'</span>
            })
        }

        <span class="hljs-keyword">const</span> nested = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'nested'</span>)
        nested.code = <span class="hljs-string">'ERRORED'</span>

        <span class="hljs-keyword">const</span> error = <span class="hljs-keyword">new</span> Config.Error(<span class="hljs-string">'FILE_READ_ERROR'</span>, [ nested ])

        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'--- stack trace ---\n'</span>)
        <span class="hljs-built_in">console</span>.log(error.stack)
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- parsed ---\n'</span>)

        <span class="hljs-keyword">const</span> object = Interrupt.parse(error.stack)

        <span class="hljs-built_in">console</span>.log(object)
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">''</span>)

        okay(<span class="hljs-built_in">Object</span>.keys(object).sort(), [
            <span class="hljs-string">'_errors'</span>, <span class="hljs-string">'className'</span>, <span class="hljs-string">'errors'</span>, <span class="hljs-string">'message'</span>, <span class="hljs-string">'properties'</span>, <span class="hljs-string">'stack'</span>
        ], <span class="hljs-string">'properties of parsed object'</span>)

        okay({
            <span class="hljs-attr">className</span>: object.className,
            <span class="hljs-attr">message</span>: object.message,
            <span class="hljs-attr">properties</span>: object.properties,
            <span class="hljs-attr">errors</span>: object.errors.map(<span class="hljs-function"><span class="hljs-params">object</span> =&gt;</span> {
                <span class="hljs-keyword">if</span> (object.className) {
                    <span class="hljs-keyword">return</span> {
                        <span class="hljs-attr">className</span>: object.className,
                        <span class="hljs-attr">message</span>: object.message,
                        <span class="hljs-attr">properties</span>: object.properties,
                        <span class="hljs-attr">errors</span>: object.errors,
                        <span class="hljs-attr">_errors</span>: object.errors,
                        <span class="hljs-attr">top</span>: path.basename(object.stack[<span class="hljs-number">0</span>].file)
                    }
                }
            }),
            <span class="hljs-attr">_errors</span>: object._errors,
            <span class="hljs-attr">top</span>: path.basename(object.stack[<span class="hljs-number">0</span>].file)
        }, {
            <span class="hljs-attr">className</span>: <span class="hljs-string">'Config.Error'</span>,
            <span class="hljs-attr">message</span>: <span class="hljs-string">'unable to read file'</span>,
            <span class="hljs-attr">properties</span>: { <span class="hljs-attr">code</span>: <span class="hljs-string">'FILE_READ_ERROR'</span> },
            <span class="hljs-attr">errors</span>: [{
                <span class="hljs-attr">className</span>: <span class="hljs-string">'Error'</span>,
                <span class="hljs-attr">message</span>: <span class="hljs-string">'nested'</span>,
                <span class="hljs-attr">properties</span>: { <span class="hljs-attr">code</span>: <span class="hljs-string">'ERRORED'</span> },
                <span class="hljs-attr">errors</span>: [],
                <span class="hljs-attr">_errors</span>: [],
                <span class="hljs-attr">top</span>: <span class="hljs-string">'readme.t.js'</span>
            }],
            <span class="hljs-attr">_errors</span>: [],
            <span class="hljs-attr">top</span>: <span class="hljs-string">'readme.t.js'</span>
        }, <span class="hljs-string">'parsed stack traces object values'</span>)
    }</pre></div></div>

        </li>


        <li id="section-433">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-433">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-434">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-434">&#182;</a>
              </div>
              <p>Errors that are not objects are serialized as JSON. There is an ambiguity
where someone could create an exception whose name is <code>null</code> has no stack
trace or properties, which would be valid JSON.</p>

            </div>

        </li>


        <li id="section-435">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-435">&#182;</a>
              </div>
              <p>As you can see from Interrupt itself, you can override the default
<code>Error</code> properties and hack the stack to create custom messages. Too much
hacking and you’ll defeat <code>Interrupt.parse()</code> so <code>Interrupt.parse()</code> will
first make sure everything is in order with a nested <code>Error</code> and if it is
not, it will serialize that <code>Error</code> as JSON.</p>

            </div>

        </li>


        <li id="section-436">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-436">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)

        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Config.Error'</span>, {
                <span class="hljs-string">'FILE_READ_ERROR'</span>: <span class="hljs-string">'unable to read file'</span>
            })
        }

        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NullError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Error</span> </span>{
            <span class="hljs-keyword">constructor</span> () {
                <span class="hljs-keyword">super</span>()
                <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>, <span class="hljs-string">'name'</span>, { <span class="hljs-attr">value</span>: <span class="hljs-string">'null'</span> })
            }
        }

        <span class="hljs-keyword">const</span> stackTraceLimit = <span class="hljs-built_in">Error</span>.stackTraceLimit
        <span class="hljs-built_in">Error</span>.stackTraceLimit = <span class="hljs-number">0</span>

        <span class="hljs-keyword">const</span> evil = <span class="hljs-keyword">new</span> NullError

        <span class="hljs-built_in">Error</span>.stackTraceLimit = stackTraceLimit</pre></div></div>

        </li>


        <li id="section-437">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-437">&#182;</a>
              </div>
              <p>_We now have an error whose <code>error.stack</code> is <code>&#39;null&#39;</code>.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        okay(evil.stack, <span class="hljs-string">'null'</span>, <span class="hljs-string">'confusing error'</span>)
        okay(Interrupt.JSON.parse(Interrupt.stringify(evil)), {
            <span class="hljs-attr">constructor</span>: <span class="hljs-string">'NullError'</span>,
            <span class="hljs-attr">error</span>: {
                <span class="hljs-attr">name</span>: <span class="hljs-string">'null'</span>,
                <span class="hljs-attr">message</span>: <span class="hljs-string">''</span>,
                <span class="hljs-attr">stack</span>: [],
                <span class="hljs-attr">properties</span>: {}
            }
        }, <span class="hljs-string">'serialized bad identifier as JSON'</span>)

        <span class="hljs-built_in">Object</span>.defineProperty(evil, <span class="hljs-string">'stack'</span>, { <span class="hljs-attr">value</span>: <span class="hljs-literal">null</span> })
        okay(evil.stack, <span class="hljs-literal">null</span>, <span class="hljs-string">'made things even worse'</span>)
        okay(Interrupt.JSON.parse(Interrupt.stringify(evil)), {
            <span class="hljs-attr">constructor</span>: <span class="hljs-string">'NullError'</span>,
            <span class="hljs-attr">error</span>: {
                <span class="hljs-attr">name</span>: <span class="hljs-string">'null'</span>,
                <span class="hljs-attr">message</span>: <span class="hljs-string">''</span>,
                <span class="hljs-attr">stack</span>: <span class="hljs-literal">null</span>,
                <span class="hljs-attr">properties</span>: {}
            }
        }, <span class="hljs-string">'serialized missing stack as JSON'</span>)

        <span class="hljs-keyword">const</span> interrupt = <span class="hljs-keyword">new</span> Config.Error(<span class="hljs-string">'FILE_READ_ERROR'</span>, [ evil ])
        <span class="hljs-built_in">console</span>.log(Interrupt.parse(interrupt.stack))
    }</pre></div></div>

        </li>


        <li id="section-438">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-438">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-439">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-439">&#182;</a>
              </div>
              <h2 id="error-heirarchies">Error Heirarchies</h2>

            </div>

        </li>


        <li id="section-440">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-440">&#182;</a>
              </div>
              <p>You can define symbols elsewhere and import them into the defintion of
your expcetion.</p>

            </div>

        </li>


        <li id="section-441">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-441">&#182;</a>
              </div>
              <p>To do so you specify a <code>symbol</code> property in your prototype definition.
The symbol will be used instead of generating a symbol for the code.</p>

            </div>

        </li>


        <li id="section-442">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-442">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`\n--- use existing external symbols ---\n`</span>)
    {
        <span class="hljs-keyword">const</span> Constants = {
            <span class="hljs-attr">IO_ERROR</span>: <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'IO_ERROR'</span>),
            <span class="hljs-attr">INVALID_ARGUMENT</span>: <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'INVALID_ARGUMENT'</span>),
            <span class="hljs-attr">ANONYMOUS_SYMBOL</span>: <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'ANONYMOUS_SYMBOL'</span>)
        }

        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Config.Error'</span>, {
                <span class="hljs-attr">IO_ERROR</span>: { <span class="hljs-attr">symbol</span>: Constants.IO_ERROR },
                <span class="hljs-attr">INVALID_ARGUMENT</span>: {
                    <span class="hljs-attr">symbol</span>: Constants.INVALID_ARGUMENT,
                    <span class="hljs-attr">message</span>: <span class="hljs-string">'invalid argument for: %(_name)s'</span>
                },
                <span class="hljs-attr">NULL_ARGUMENT</span>: {
                    <span class="hljs-attr">symbol</span>: Constants.ANONYMOUS_SYMBOL,
                    <span class="hljs-attr">message</span>: <span class="hljs-string">'argument must not be null: %(_name)s'</span>
                }
            })
        }

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Config.Error(<span class="hljs-string">'IO_ERROR'</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>`</span>)
            okay(error.symbol, Config.Error.IO_ERROR, <span class="hljs-string">'use symbol'</span>)
            okay(error.code, <span class="hljs-string">'IO_ERROR'</span>, <span class="hljs-string">'use symbol name as code'</span>)
            okay(Interrupt.message(error), <span class="hljs-string">'IO_ERROR'</span>, <span class="hljs-string">'use symbol name as message'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-443">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-443">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-444">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-444">&#182;</a>
              </div>
              <p>To inherit a codes and aliases from the parent you must use a code
function.</p>

            </div>

        </li>


        <li id="section-445">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-445">&#182;</a>
              </div>
              <p>The code function is with a <code>Super</code> property that contains an object. The
<code>Super</code> contains a <code>Codes</code> property containing the codes of super class
indexed by the code name and an <code>Alaises</code> property containing the aliases
of the super class indexed by code name.</p>

            </div>

        </li>


        <li id="section-446">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-446">&#182;</a>
              </div>
              <p>You can import code from the parent by returning one of the code objects
from the <code>Super.Codes</code> object.</p>

            </div>

        </li>


        <li id="section-447">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-447">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'\n--- inherit a code ---\n'</span>)
    {
        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Config.Error'</span>, {
                <span class="hljs-attr">IO_ERROR</span>: {
                    <span class="hljs-attr">message</span>: <span class="hljs-string">'i/o error'</span>,
                    <span class="hljs-attr">recoverable</span>: <span class="hljs-literal">true</span>
                },
                <span class="hljs-attr">PARSE_ERROR</span>: <span class="hljs-string">'unable to parse'</span>,
                <span class="hljs-attr">NULL_ARGUMENT</span>: <span class="hljs-string">'must not be null'</span>
            })
        }

        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Derived.Error'</span>, Config.Error, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">{ Super }</span>) </span>{
                <span class="hljs-keyword">return</span> Super.Codes.IO_ERROR
            })
        }

        okay(Config.Error.IO_ERROR === Derived.Error.IO_ERROR, <span class="hljs-string">'symbols inherited'</span>)

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Derived.Error(<span class="hljs-string">'IO_ERROR'</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(Interrupt.message(error), <span class="hljs-string">'i/o error'</span>, <span class="hljs-string">'inherit message format'</span>)
            okay(error.code, <span class="hljs-string">'IO_ERROR'</span>, <span class="hljs-string">'inherit code name'</span>)
            okay(error.symbol, Config.Error.IO_ERROR, <span class="hljs-string">'inherit code symbol'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-448">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-448">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-449">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-449">&#182;</a>
              </div>
              <p>You can import all the codes at once by returning the <code>Super.Codes</code> object.</p>

            </div>

        </li>


        <li id="section-450">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-450">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Config.Error'</span>, {
                <span class="hljs-attr">IO_ERROR</span>: {
                    <span class="hljs-attr">message</span>: <span class="hljs-string">'i/o error'</span>,
                    <span class="hljs-attr">recoverable</span>: <span class="hljs-literal">true</span>
                },
                <span class="hljs-attr">PARSE_ERROR</span>: <span class="hljs-string">'unable to parse'</span>,
                <span class="hljs-attr">NULL_ARGUMENT</span>: <span class="hljs-string">'must not be null'</span>
            })
        }

        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Derived.Error'</span>, Config.Error, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">{ Super }</span>) </span>{
                <span class="hljs-keyword">return</span> Super.Codes
            })
        }

        okay(Derived.Error.codes.sort(), [ <span class="hljs-string">'IO_ERROR'</span>, <span class="hljs-string">'NULL_ARGUMENT'</span>, <span class="hljs-string">'PARSE_ERROR'</span> ], <span class="hljs-string">'all codes inherited'</span>)
        okay((
            Config.Error.IO_ERROR === Derived.Error.IO_ERROR &amp;&amp;
            Config.Error.PARSE_ERROR === Derived.Error.PARSE_ERROR
        ), <span class="hljs-string">'symbols inherited'</span>)

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Derived.Error(<span class="hljs-string">'IO_ERROR'</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(Interrupt.message(error), <span class="hljs-string">'i/o error'</span>, <span class="hljs-string">'inherit message format'</span>)
            okay(error.code, <span class="hljs-string">'IO_ERROR'</span>, <span class="hljs-string">'inherit code name'</span>)
            okay(error.symbol, Config.Error.IO_ERROR, <span class="hljs-string">'inherit code symbol'</span>)
            okay(error.recoverable,  <span class="hljs-string">'inherit default property'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-451">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-451">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-452">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-452">&#182;</a>
              </div>
              <p>You can always return an code array, code object or another code function
so you can use one of these to return a subset of codes to import.</p>

            </div>

        </li>


        <li id="section-453">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-453">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Config.Error'</span>, {
                <span class="hljs-attr">IO_ERROR</span>: {
                    <span class="hljs-attr">message</span>: <span class="hljs-string">'i/o error'</span>,
                    <span class="hljs-attr">recoverable</span>: <span class="hljs-literal">true</span>
                },
                <span class="hljs-attr">PARSE_ERROR</span>: <span class="hljs-string">'unable to parse'</span>,
                <span class="hljs-attr">NULL_ARGUMENT</span>: <span class="hljs-string">'must not be null'</span>
            })
        }

        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Derived.Error'</span>, Config.Error, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">{ Super }</span>) </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(Super.Codes)
                             .filter(<span class="hljs-function"><span class="hljs-params">code</span> =&gt;</span> ! Super.Codes[code].recoverable)
                             .map(<span class="hljs-function"><span class="hljs-params">code</span> =&gt;</span> Super.Codes[code])
            })
        }

        okay(Derived.Error.codes.sort(), [ <span class="hljs-string">'NULL_ARGUMENT'</span>, <span class="hljs-string">'PARSE_ERROR'</span> ], <span class="hljs-string">'all codes inherited'</span>)
        okay((
            Config.Error.IO_ERROR === Derived.Error.IO_ERROR &amp;&amp;
            Config.Error.PARSE_ERROR === Derived.Error.PARSE_ERROR
        ), <span class="hljs-string">'symbols inherited'</span>)

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Derived.Error(<span class="hljs-string">'NULL_ARGUMENT'</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(Interrupt.message(error), <span class="hljs-string">'must not be null'</span>, <span class="hljs-string">'inherit message format'</span>)
            okay(error.code, <span class="hljs-string">'NULL_ARGUMENT'</span>, <span class="hljs-string">'inherit code name'</span>)
            okay(error.symbol, Config.Error.NULL_ARGUMENT, <span class="hljs-string">'inherit code symbol'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-454">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-454">&#182;</a>
              </div>
              <p>If you want to inherit a code and extend it you use the Super’s code
object as the <code>code</code> property of a defintion. The properties of the
parent’s code will be merged with your definition preserving the property
settings <code>enumerable</code>, <code>writable</code> and <code>configurable</code>.</p>

            </div>

        </li>


        <li id="section-455">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-455">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Config.Error'</span>, {
                <span class="hljs-attr">IO_ERROR</span>: {
                    <span class="hljs-attr">message</span>: <span class="hljs-string">'i/o error'</span>,
                    <span class="hljs-attr">recoverable</span>: <span class="hljs-literal">true</span>
                },
                <span class="hljs-attr">PARSE_ERROR</span>: <span class="hljs-string">'unable to parse'</span>
            })
        }

        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Derived.Error'</span>, Config.Error, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">{ Super }</span>) </span>{
                <span class="hljs-keyword">return</span> {
                    <span class="hljs-attr">IO_ERROR</span>: {
                        <span class="hljs-attr">code</span>: Super.Codes.IO_ERROR,
                        <span class="hljs-attr">recoverable</span>: <span class="hljs-literal">false</span>,
                        <span class="hljs-attr">type</span>: <span class="hljs-string">'directory'</span>
                    }
                }
            })
        }

        okay(Config.Error.IO_ERROR === Derived.Error.IO_ERROR, <span class="hljs-string">'symbols inherited'</span>)

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Derived.Error(<span class="hljs-string">'IO_ERROR'</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(Interrupt.message(error), <span class="hljs-string">'i/o error'</span>, <span class="hljs-string">'inherit message format'</span>)
            okay(error.code, <span class="hljs-string">'IO_ERROR'</span>, <span class="hljs-string">'inherit code name'</span>)
            okay(error.symbol, Config.Error.IO_ERROR, <span class="hljs-string">'inherit code symbol'</span>)
            okay(error.recoverable, <span class="hljs-literal">false</span>, <span class="hljs-string">'override default property'</span>)
            okay(error.type, <span class="hljs-string">'directory'</span>,  <span class="hljs-string">'add default property'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-456">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-456">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-457">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-457">&#182;</a>
              </div>
              <p>You’re not able to remove properties when you override. You can however,
just redeclare the inherited property as code with an imported symbol.</p>

            </div>

        </li>


        <li id="section-458">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-458">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Config.Error'</span>, {
                <span class="hljs-attr">IO_ERROR</span>: {
                    <span class="hljs-attr">message</span>: <span class="hljs-string">'i/o error'</span>,
                    <span class="hljs-attr">recoverable</span>: <span class="hljs-literal">true</span>
                }
            })
        }</pre></div></div>

        </li>


        <li id="section-459">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-459">&#182;</a>
              </div>
              <p><strong>TODO</strong> Expose properties, that is make it a part of the codes
object.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Derived.Error'</span>, Config.Error, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">{ Super }</span>) </span>{
                <span class="hljs-keyword">return</span> {
                    <span class="hljs-attr">IO_ERROR</span>: {
                        <span class="hljs-attr">symbol</span>: Super.Codes.IO_ERROR.symbol,
                        <span class="hljs-attr">message</span>: <span class="hljs-string">'i/o error'</span>, <span class="hljs-comment">// Super.Codes.properties.message</span>
                        type: <span class="hljs-string">'directory'</span>
                    }
                }
            })
        }

        okay(Config.Error.IO_ERROR === Derived.Error.IO_ERROR, <span class="hljs-string">'symbols inherited'</span>)

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Derived.Error(<span class="hljs-string">'IO_ERROR'</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(Interrupt.message(error), <span class="hljs-string">'i/o error'</span>, <span class="hljs-string">'inherit message format'</span>)
            okay(error.code, <span class="hljs-string">'IO_ERROR'</span>, <span class="hljs-string">'inherit code name'</span>)
            okay(error.symbol, Config.Error.IO_ERROR, <span class="hljs-string">'inherit code symbol'</span>)
            okay(!(<span class="hljs-string">'recoverable'</span> <span class="hljs-keyword">in</span> error), <span class="hljs-string">'override default property'</span>)
            okay(error.type, <span class="hljs-string">'directory'</span>,  <span class="hljs-string">'add default property'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-460">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-460">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-461">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-461">&#182;</a>
              </div>
              <p>You can import all of the codes, but override or replace some of them
using JavaScript destructuring.</p>

            </div>

        </li>


        <li id="section-462">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-462">&#182;</a>
              </div>
              <p>In this example we destructure the entire <code>Super.Codes</code> object into a new
object, which will import them as is, while at the same time extending
a specific code.</p>

            </div>

        </li>


        <li id="section-463">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-463">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Config.Error'</span>, {
                <span class="hljs-attr">IO_ERROR</span>: {
                    <span class="hljs-attr">message</span>: <span class="hljs-string">'i/o error'</span>,
                    <span class="hljs-attr">recoverable</span>: <span class="hljs-literal">true</span>
                },
                <span class="hljs-attr">PARSE_ERROR</span>: <span class="hljs-string">'unable to parse'</span>
            })
        }

        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Derived.Error'</span>, Config.Error, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">{ Super }</span>) </span>{
                <span class="hljs-keyword">return</span> {
                    ...Super.Codes,
                    <span class="hljs-attr">IO_ERROR</span>: {
                        <span class="hljs-attr">code</span>: Super.Codes.IO_ERROR,
                        <span class="hljs-attr">type</span>: <span class="hljs-string">'directory'</span>
                    }
                }
            })
        }

        okay(Config.Error.IO_ERROR === Derived.Error.IO_ERROR, <span class="hljs-string">'symbols inherited'</span>)

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Derived.Error(<span class="hljs-string">'IO_ERROR'</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(Interrupt.message(error), <span class="hljs-string">'i/o error'</span>, <span class="hljs-string">'inherit message format'</span>)
            okay(error.code, <span class="hljs-string">'IO_ERROR'</span>, <span class="hljs-string">'inherit code name'</span>)
            okay(error.symbol, Config.Error.IO_ERROR, <span class="hljs-string">'inherit code symbol'</span>)
            okay(error.recoverable, <span class="hljs-string">'inherit default property'</span>)
            okay(error.type, <span class="hljs-string">'directory'</span>,  <span class="hljs-string">'add default property'</span>)
        }
    }</pre></div></div>

        </li>


        <li id="section-464">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-464">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-465">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-465">&#182;</a>
              </div>
              <p>You can also import aliases.</p>

            </div>

        </li>


        <li id="section-466">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-466">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    {
        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Config.Error'</span>, {
                <span class="hljs-attr">IO_ERROR</span>: {
                    <span class="hljs-attr">message</span>: <span class="hljs-string">'i/o error'</span>,
                    <span class="hljs-attr">recoverable</span>: <span class="hljs-literal">true</span>
                },
                <span class="hljs-attr">PARSE_ERROR</span>: <span class="hljs-string">'unable to parse'</span>,
                <span class="hljs-attr">FILE_ERROR</span>: {
                    <span class="hljs-attr">code</span>: <span class="hljs-string">'IO_ERROR'</span>,
                    <span class="hljs-attr">message</span>: <span class="hljs-string">'the file cannot be read'</span>,
                    <span class="hljs-attr">type</span>: <span class="hljs-string">'file'</span>
                }
            })
        }

        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Derived.Error'</span>, Config.Error, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">{ Super }</span>) </span>{
                <span class="hljs-built_in">console</span>.log(Super.Aliases)
                <span class="hljs-keyword">return</span> {
                    <span class="hljs-attr">IO_ERROR</span>: Super.Codes.IO_ERROR,
                    ...Super.Aliases
                }
            })
        }

        okay(Config.Error.IO_ERROR === Derived.Error.IO_ERROR, <span class="hljs-string">'symbols inherited'</span>)

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Derived.Error(<span class="hljs-string">'FILE_ERROR'</span>)
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${error.stack}</span>\n`</span>)
            okay(Interrupt.message(error), <span class="hljs-string">'the file cannot be read'</span>, <span class="hljs-string">'inherit message format'</span>)
            okay(error.code, <span class="hljs-string">'IO_ERROR'</span>, <span class="hljs-string">'inherit code name'</span>)
            okay(error.symbol, Config.Error.IO_ERROR, <span class="hljs-string">'inherit code symbol'</span>)
            okay(error.recoverable, <span class="hljs-string">'inherit default property'</span>)
            okay(error.type, <span class="hljs-string">'file'</span>,  <span class="hljs-string">'add default property'</span>)
        }
    }

    {
        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span> </span>{
            <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Config.Error'</span>, {
                <span class="hljs-attr">IO_ERROR</span>: {
                    <span class="hljs-attr">message</span>: <span class="hljs-string">'i/o error'</span>,
                    <span class="hljs-attr">recoverable</span>: <span class="hljs-literal">true</span>
                }
            })
        }

        okay(<span class="hljs-keyword">new</span> Config.Error().toString(), <span class="hljs-string">'Config.Error'</span>, <span class="hljs-string">'no message to string'</span>)
        okay(<span class="hljs-keyword">new</span> Config.Error(<span class="hljs-string">'IO_ERROR'</span>).toString(), <span class="hljs-string">'Config.Error: i/o error'</span>, <span class="hljs-string">'with message to string'</span>)
    }

})</pre></div></div>

        </li>

    </ul>
  </div>
</body>
</html>
