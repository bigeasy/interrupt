<!DOCTYPE html>

<html>
<head>
  <title>interrupt.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>

      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page_wrapper">
            <div id="jump_page">


                <a class="source" href="interrupt.js.html">
                  interrupt.js
                </a>


                <a class="source" href="location.js.html">
                  location.js
                </a>


                <a class="source" href="readme.t.js.html">
                  readme.t.js
                </a>

            </div>
          </div>
        </li>
      </ul>

    <ul class="sections">

          <li id="title">
              <div class="annotation">
                  <h1>interrupt.js</h1>
              </div>
          </li>



        <li id="section-1">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>Node.js API.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>)</pre></div></div>

        </li>


        <li id="section-2">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Return the first non-<code>null</code> like parameter.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> coalesce = <span class="hljs-built_in">require</span>(<span class="hljs-string">'extant'</span>)</pre></div></div>

        </li>


        <li id="section-3">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Deep differences.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> Keyify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'keyify'</span>)</pre></div></div>

        </li>


        <li id="section-4">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Weak map of instances to construction material used for de-duplication and
reporting to report the errors of our errors. Errors in JavaScript are simple
objects and utilities that encounter them will do things like print their
properties to console so protected status of protected properties is likely
to be violated.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> Instances = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>

<span class="hljs-keyword">const</span> Prototypes = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span></pre></div></div>

        </li>


        <li id="section-5">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Parse the file and line number from a Node.js stack trace.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> location = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./location'</span>)</pre></div></div>

        </li>


        <li id="section-6">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p><code>sprintf</code> supports named parameters so we can use our parameters object to
fill in the <code>sprintf</code> place-holders.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> sprintf = <span class="hljs-built_in">require</span>(<span class="hljs-string">'sprintf-js'</span>).sprintf</pre></div></div>

        </li>


        <li id="section-7">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Used to assert that the constructor is only ever called from a generated
derived Interrupt class.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> PROTECTED = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'PROTECTED'</span>)</pre></div></div>

        </li>


        <li id="section-8">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>The value of the <code>type</code> property for the options object to the constructor.
Use for disambiguation when currying <code>assert</code>.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> OPTIONS = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'OPTIONS'</span>)</pre></div></div>

        </li>


        <li id="section-9">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>This is a place-holder object for the nested exception when we generate
exceptions to audit assertions and guarded functions.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> AUDIT = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'example'</span>)</pre></div></div>

        </li>


        <li id="section-10">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Generate the message for the Goole V8 exception. The message is specially
formatted to appear integrated with the stack trace from <code>error.stack</code> which
includes the message in the stack trace.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">context</span> (<span class="hljs-params">options, instance, stack = true</span>) </span>{</pre></div></div>

        </li>


        <li id="section-11">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Attempt to use the options message as a <code>sprintf</code> format. Use the message
as is if <code>sprintf</code> fails.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">let</span> message = instance.message = options.message
    <span class="hljs-keyword">try</span> {
        message = instance.message = sprintf(options.message, options)
    } <span class="hljs-keyword">catch</span> (error) {
        instance.errors.push({
            <span class="hljs-attr">code</span>: Interrupt.Error.SPRINTF_ERROR,
            <span class="hljs-attr">format</span>: options.format,
            <span class="hljs-attr">properties</span>: options.properties,
            <span class="hljs-attr">error</span>: error
        })
    }</pre></div></div>

        </li>


        <li id="section-12">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>The enumerable properties, if any, of the object using our special JSON.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.keys(instance.displayed).length != <span class="hljs-number">0</span>) {
        message += <span class="hljs-string">'\n\n'</span> + Interrupt.JSON.stringify(instance.displayed)
    }</pre></div></div>

        </li>


        <li id="section-13">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p><strong>TODO</strong> Without context messages we have more space. We could, if the
type is not an Error, serialize the cause as JSON. Parsing would be a
matter of detecting if it is an error, if not it is going to be JSON.
JSON will not look like an error, perhaps just plain <code>null</code> would be
confusing, but I doubt it.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (options.errors.length) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, I = options.errors.length; i &lt; I; i++) {
            <span class="hljs-keyword">const</span> error = options.errors[i]
            <span class="hljs-keyword">const</span> text = error <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span> ? Interrupt.stringify(error) : error.toString()
            <span class="hljs-keyword">const</span> indented = text.replace(<span class="hljs-regexp">/^/gm</span>, <span class="hljs-string">'    '</span>)
            message += <span class="hljs-string">'\n\ncause:\n\n'</span> + indented
        }
    }</pre></div></div>

        </li>


        <li id="section-14">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>A header for the stack trace unless the stack trace has been suppressed.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (stack &amp;&amp; (options[<span class="hljs-string">'#stack'</span>] == <span class="hljs-literal">null</span> || options[<span class="hljs-string">'#stack'</span>] != <span class="hljs-number">0</span>)) {
        message += <span class="hljs-string">'\n\nstack:\n'</span>
    }

    <span class="hljs-keyword">return</span> message
}</pre></div></div>

        </li>


        <li id="section-15">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>A utility to merge two or more objects preserving their descriptor traits.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">combine</span> (<span class="hljs-params">...vargs</span>) </span>{
    <span class="hljs-keyword">const</span> properties = {}
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> object <span class="hljs-keyword">of</span> vargs) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> property <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.getOwnPropertyNames(object)) {
            properties[property] = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, property)
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.defineProperties({}, properties)
}</pre></div></div>

        </li>


        <li id="section-16">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Get an object from a tree of objects <code>object</code> using the given array of
indexes in the given <code>path</code>. Used by our specialized JSON to generate and
resolve references.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span> (<span class="hljs-params">object, path</span>) </span>{
    <span class="hljs-keyword">let</span> iterator = object
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> part <span class="hljs-keyword">of</span> path) {
        iterator = iterator[part]
    }
    <span class="hljs-keyword">return</span> iterator
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Collector</span> </span>{
    <span class="hljs-keyword">constructor</span> () {
        <span class="hljs-keyword">this</span>._lines = []
    }

    push (line) {
        <span class="hljs-keyword">this</span>._lines.push(line)
    }

    end () {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._lines[<span class="hljs-keyword">this</span>._lines.length - <span class="hljs-number">1</span>] === <span class="hljs-string">''</span>) {
            <span class="hljs-keyword">this</span>._lines.pop()
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._lines.join(<span class="hljs-string">'\n'</span>)
    }
}</pre></div></div>

        </li>


        <li id="section-17">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>An assert internal to Interrupt that will not get audited.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assert</span> (<span class="hljs-params">condition, ...vargs</span>) </span>{
    <span class="hljs-keyword">if</span> (! condition) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Interrupt.Error(Interrupt.Error.options.apply(Interrupt.Error, [{ <span class="hljs-string">'#callee'</span>: assert }].concat(vargs)))
    }
}</pre></div></div>

        </li>


        <li id="section-18">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>The Interrupt class extends <code>Error</code> using class ES6 extension.</p>

            </div>

        </li>


        <li id="section-19">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Interrupt</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Error</span> </span>{</pre></div></div>

        </li>


        <li id="section-20">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Private static initializer. We are committed to Node.js 12 or greater.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    static #initializer = (function () {
        Prototypes.set(Interrupt, {
            is: new Map, Super: { Codes: {}, Aliases: {} }
        })
    } ())</pre></div></div>

        </li>


        <li id="section-21">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p><strong>TODO</strong> Maybe a set of common symbols mapped to the existing Node.js
error types? No, the ability to specify a symbol, but it must be unique,
and we can put those types in <code>Interrupt.Error</code>.</p>

            </div>

        </li>


        <li id="section-22">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>The <code>Interrupt.Error</code> class is itself an interrupt defined error.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">'Interrupt.Error'</span>, {</pre></div></div>

        </li>


        <li id="section-23">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p><strong>TODO</strong> Rename.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        INVALID_CODE: <span class="hljs-string">'code is already a property of the superclass'</span>,
        <span class="hljs-attr">UNKNOWN_CODE</span>: <span class="hljs-string">'unknown code'</span>,
        <span class="hljs-attr">INVALID_CODE_TYPE</span>: <span class="hljs-string">'invalid code type'</span>,
        <span class="hljs-attr">INVALID_ACCESS</span>: <span class="hljs-string">'constructor is not a public interface'</span>,
        <span class="hljs-attr">PARSE_ERROR</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">SPRINTF_ERROR</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">NULL_ARGUMENT</span>: <span class="hljs-string">'null argument given to exception constructor'</span>,
        <span class="hljs-attr">INVALID_PROPERTY_NAME</span>: <span class="hljs-string">'invalid property name'</span>,
        <span class="hljs-attr">INVALID_PROPERTY_TYPE</span>: <span class="hljs-string">'invalid property type'</span>,
        <span class="hljs-attr">INVALID_PROPERTY_NAME</span>: <span class="hljs-string">'invalid property name'</span>,
        <span class="hljs-attr">DEFERRED_CONSTRUCTOR_INVALID_RETURN</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">DEFERRED_CONSTRUCTOR_NOT_CALLED</span>: <span class="hljs-literal">null</span>
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">{ Codes }</span>) </span>{
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">SUPER_PROTOTYPE_MISSING</span>: {
                <span class="hljs-attr">code</span>: Codes.INVALID_CODE.symbol,
                <span class="hljs-attr">message</span>: <span class="hljs-string">'attempt to define alias of non-existant code or alias'</span>
            },
            <span class="hljs-attr">SYMBOLS_NOT_ALLOWED</span>: {
                <span class="hljs-attr">code</span>: Codes.INVALID_CODE.symbol,
                <span class="hljs-attr">message</span>: <span class="hljs-string">'code alias definitions cannot define a `symbol` property'</span>
            }
        }
    })

    <span class="hljs-keyword">static</span> explode (error) {
        <span class="hljs-keyword">const</span> preamble = error.message == <span class="hljs-string">''</span>
            ? <span class="hljs-string">`<span class="hljs-subst">${error.name}</span>`</span>
            : <span class="hljs-string">`<span class="hljs-subst">${error.name}</span>: <span class="hljs-subst">${error.message}</span>`</span>
        <span class="hljs-keyword">if</span> (
            error.name == <span class="hljs-literal">null</span> ||
            error.message == <span class="hljs-literal">null</span> ||
            error.stack == <span class="hljs-literal">null</span> ||
            error.stack.indexOf(preamble) != <span class="hljs-number">0</span> ||
            !RE.identifier.test(error.name)
        ) {
            <span class="hljs-keyword">return</span> [{
                <span class="hljs-attr">constructor</span>: error.constructor.name,
                <span class="hljs-attr">error</span>: {
                    <span class="hljs-attr">name</span>: error.name,
                    <span class="hljs-attr">message</span>: error.message,
                    <span class="hljs-attr">stack</span>: error.stack == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : unstacker.parse(error.stack),
                    <span class="hljs-attr">properties</span>: { ...error }
                }
            }]
        }
        <span class="hljs-keyword">const</span> stack = error.stack[preamble.length] == <span class="hljs-string">'\n'</span>
            ? error.stack.substring(preamble.length + <span class="hljs-number">1</span>)
            : error.stack.substring(preamble.length)
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">name</span>: error.name,
            <span class="hljs-attr">message</span>: error.message,
            <span class="hljs-attr">properties</span>: { ...error },
            <span class="hljs-attr">stack</span>: stack
        }
    }

    <span class="hljs-keyword">static</span> stringify (error) {
        <span class="hljs-keyword">if</span> (error <span class="hljs-keyword">instanceof</span> Interrupt) {
            <span class="hljs-keyword">return</span> error.stack
        }
        <span class="hljs-keyword">const</span> exploded = Interrupt.explode(error)
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(exploded)) {
            <span class="hljs-keyword">return</span> Interrupt.JSON.stringify(exploded[<span class="hljs-number">0</span>])
        }
        <span class="hljs-keyword">if</span> (exploded.message == <span class="hljs-string">''</span> &amp;&amp; <span class="hljs-built_in">Object</span>.keys(exploded.properties).length == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> error.stack
        }
        <span class="hljs-keyword">const</span> message = error.message.split(<span class="hljs-string">'\n'</span>)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>, I = message.length; i &lt; I; i++) {
            message[i] = <span class="hljs-string">`    <span class="hljs-subst">${message[i]}</span>`</span>
        }
        <span class="hljs-keyword">const</span> title = exploded.message == <span class="hljs-string">''</span>
            ? <span class="hljs-string">`<span class="hljs-subst">${exploded.name}</span>`</span>
            : <span class="hljs-string">`<span class="hljs-subst">${exploded.name}</span>: <span class="hljs-subst">${message.join(<span class="hljs-string">'\n'</span>)}</span>`</span>
        <span class="hljs-keyword">const</span> header = <span class="hljs-built_in">Object</span>.keys(exploded.properties).length == <span class="hljs-number">0</span>
            ? title
            : <span class="hljs-string">`<span class="hljs-subst">${title}</span>\n\n<span class="hljs-subst">${Interrupt.<span class="hljs-built_in">JSON</span>.stringify(exploded.properties)}</span>`</span>
        <span class="hljs-keyword">if</span> (exploded.stack.length == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> header
        }
        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${header}</span>\n\nstack:\n\n<span class="hljs-subst">${exploded.stack}</span>`</span>
    }

    <span class="hljs-keyword">static</span> Parser = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parser</span> </span>{
        <span class="hljs-keyword">constructor</span> (scan = false) {
            <span class="hljs-keyword">this</span>._scannable = scan
            <span class="hljs-keyword">this</span>._scanning = scan
            <span class="hljs-keyword">this</span>._mode = scan ? <span class="hljs-string">'scan'</span> : <span class="hljs-string">'exception'</span>
            <span class="hljs-keyword">this</span>._collector = <span class="hljs-literal">null</span>
            <span class="hljs-keyword">this</span>._depth = <span class="hljs-number">0</span>
            <span class="hljs-keyword">this</span>._position = { <span class="hljs-attr">line</span>: <span class="hljs-number">1</span> }
        }

        <span class="hljs-keyword">static</span> _DEDENT = {
            <span class="hljs-string">'message'</span>: <span class="hljs-number">1</span>,
            <span class="hljs-string">'properties'</span>: <span class="hljs-number">0</span>,
            <span class="hljs-string">'stack'</span>: <span class="hljs-number">0</span>
        }</pre></div></div>

        </li>


        <li id="section-24">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p><strong>TODO</strong> Need to be regex so we can detect a naked error with no
message and a stack that starts with <code>&#39;    at&#39;</code>.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">static</span> _START = {
            <span class="hljs-string">'properties'</span>: <span class="hljs-string">'{'</span>,
            <span class="hljs-string">'stack'</span>: <span class="hljs-string">'stack:'</span>,
            <span class="hljs-string">'errors'</span>: <span class="hljs-string">'cause:'</span>
        }

        <span class="hljs-keyword">static</span> _TRANSITION = {
            <span class="hljs-string">'message'</span>: [ <span class="hljs-string">'properties'</span>, <span class="hljs-string">'errors'</span>, <span class="hljs-string">'stack'</span> ],
            <span class="hljs-string">'properties'</span>: [ <span class="hljs-string">'errors'</span>, <span class="hljs-string">'stack'</span> ],
            <span class="hljs-string">'errors'</span>: [ <span class="hljs-string">'errors'</span>, <span class="hljs-string">'stack'</span> ],
            <span class="hljs-string">'stack'</span>: [],
            <span class="hljs-string">'object'</span>: []
        }

        <span class="hljs-keyword">static</span> _INCLUDE = {
            <span class="hljs-string">'message'</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-string">'properties'</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-string">'errors'</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-string">'stack'</span>: <span class="hljs-string">'false'</span>
        }

        _complete () {
            <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>._mode) {
            <span class="hljs-keyword">case</span> <span class="hljs-string">'message'</span>: {
                    <span class="hljs-keyword">this</span>._node.message = <span class="hljs-keyword">this</span>._collector.end()
                    <span class="hljs-keyword">this</span>._collector.length = <span class="hljs-number">0</span>
                }
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">case</span> <span class="hljs-string">'properties'</span>: {
                    <span class="hljs-keyword">this</span>._node.properties = Interrupt.JSON.parse(<span class="hljs-keyword">this</span>._collector.end())
                }
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">case</span> <span class="hljs-string">'stack'</span>: {
                    <span class="hljs-keyword">this</span>._node.stack = unstacker.parse(<span class="hljs-keyword">this</span>._collector.end())
                }
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">case</span> <span class="hljs-string">'errors'</span>: {
                    <span class="hljs-keyword">this</span>._node.errors.push(<span class="hljs-keyword">this</span>._collector.end())
                }
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">case</span> <span class="hljs-string">'object'</span>: {
                    <span class="hljs-keyword">this</span>._node = Interrupt.JSON.parse(<span class="hljs-keyword">this</span>._collector.end())
                }
                <span class="hljs-keyword">break</span>
            }
        }

        _transition (source) {
            <span class="hljs-attr">MODES</span>: <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> mode <span class="hljs-keyword">of</span> Interrupt.Parser._TRANSITION[<span class="hljs-keyword">this</span>._mode]) {
                <span class="hljs-keyword">if</span> (source.trimRight() === Interrupt.Parser._START[mode]) {
                    <span class="hljs-keyword">this</span>._complete()
                    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>._mode = mode) {
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'errors'</span>: {
                            <span class="hljs-keyword">this</span>._collector = <span class="hljs-keyword">new</span> Interrupt.Parser
                            <span class="hljs-keyword">this</span>._collector._mode = <span class="hljs-string">'cause'</span>
                        }
                        <span class="hljs-keyword">break</span>
                    <span class="hljs-keyword">default</span>: {
                            <span class="hljs-keyword">this</span>._collector = <span class="hljs-keyword">new</span> Collector
                        }
                        <span class="hljs-keyword">break</span>
                    }
                    <span class="hljs-keyword">return</span> Interrupt.Parser._INCLUDE[<span class="hljs-keyword">this</span>._mode]
                }
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
        }

        _exception (line) {
            <span class="hljs-keyword">const</span> $ = RE.exceptionStart.exec(line)
            <span class="hljs-keyword">if</span> ($ != <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">const</span> [ , space, className, separator, message ] = $
                <span class="hljs-keyword">this</span>._depth = space.length
                <span class="hljs-keyword">this</span>._collector = <span class="hljs-keyword">new</span> Collector
                <span class="hljs-keyword">this</span>._node = {
                    <span class="hljs-attr">className</span>: className,
                    <span class="hljs-attr">message</span>: <span class="hljs-literal">null</span>,
                    <span class="hljs-attr">properties</span>: {},
                    <span class="hljs-attr">errors</span>: [],
                    <span class="hljs-attr">_errors</span>: [],
                    <span class="hljs-attr">stack</span>: []
                }
                <span class="hljs-keyword">if</span> (separator != <span class="hljs-literal">null</span>) {
                    <span class="hljs-keyword">this</span>._collector.push(message)
                }
                <span class="hljs-keyword">this</span>._mode = <span class="hljs-string">'message'</span>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        }

        push(line) {
            <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>._mode) {
            <span class="hljs-keyword">case</span> <span class="hljs-string">'exception'</span>: {
                    <span class="hljs-keyword">this</span>._position = { <span class="hljs-attr">line</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">text</span>: line }
                    <span class="hljs-keyword">const</span> dedented = dedent(line, <span class="hljs-keyword">this</span>._depth, <span class="hljs-keyword">this</span>._position)
                    <span class="hljs-keyword">const</span> $ = RE.exceptionStart.exec(line)
                    assert($ != <span class="hljs-literal">null</span>, <span class="hljs-string">'PARSE_ERROR'</span>, <span class="hljs-keyword">this</span>._position)
                    <span class="hljs-keyword">const</span> [ , space, className, separator, message ] = $
                    <span class="hljs-keyword">this</span>._depth = space.length
                    <span class="hljs-keyword">this</span>._collector = <span class="hljs-keyword">new</span> Collector
                    <span class="hljs-keyword">this</span>._node = {
                        <span class="hljs-attr">className</span>: className,
                        <span class="hljs-attr">message</span>: <span class="hljs-literal">null</span>,
                        <span class="hljs-attr">properties</span>: {},
                        <span class="hljs-attr">errors</span>: [],
                        <span class="hljs-attr">_errors</span>: [],
                        <span class="hljs-attr">stack</span>: []
                    }
                    <span class="hljs-keyword">if</span> (separator != <span class="hljs-literal">null</span>) {
                        <span class="hljs-keyword">this</span>._collector.push(message)
                    }
                    <span class="hljs-keyword">this</span>._mode = <span class="hljs-string">'message'</span>
                }
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">case</span> <span class="hljs-string">'cause'</span>: {
                    <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/\S+/</span>.test(line) &amp;&amp; ! <span class="hljs-keyword">this</span>._exception(line)) {
                        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'OH, NO!'</span>)
                        <span class="hljs-keyword">this</span>._collector = <span class="hljs-keyword">new</span> Collector
                        <span class="hljs-keyword">this</span>._collector.push(line)
                        <span class="hljs-keyword">this</span>._mode = <span class="hljs-string">'object'</span>
                    }
                }
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">default</span>: {
                    <span class="hljs-keyword">this</span>._position.line++
                    <span class="hljs-keyword">this</span>._position.text = line
                    <span class="hljs-keyword">const</span> dedented = dedent(line, <span class="hljs-keyword">this</span>._depth, <span class="hljs-keyword">this</span>._position)
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._transition(dedented, <span class="hljs-string">'properties'</span>, <span class="hljs-string">'cause'</span>, <span class="hljs-string">'stack'</span>)) {
                        <span class="hljs-keyword">this</span>._collector.push(dedent(dedented, <span class="hljs-keyword">this</span>._mode == <span class="hljs-string">'message'</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>._position))
                    }
                }
                <span class="hljs-keyword">break</span>
            }
        }

        end () {
            <span class="hljs-keyword">this</span>._complete()
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._node
        }
    }</pre></div></div>

        </li>


        <li id="section-25">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>We implement custom JSON serialization that supports circular references
because we don’t want to raise an exception on bad JSON because JSON
serialization is used for printing out the properties on the error path.
We don’t want to raise an exception on bad JSON and we don’t want to
neglect to say as much as we can about the properties we’ve been given.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">JSON</span> = {</pre></div></div>

        </li>


        <li id="section-26">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Stringify visits each object in the object to look for duplicate
objects and mark them for reference construction in the replacer. It
does not create a copy of the object because we want
<code>JSON.stringify()</code> is to resolve the <code>.toJSON()</code> conversions.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        stringify (object) {
            <span class="hljs-keyword">const</span> seen = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>
            <span class="hljs-keyword">const</span> replacements = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visit</span> (<span class="hljs-params">path, value</span>) </span>{
                <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">typeof</span> value) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">'object'</span>: {
                        <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) {
                            <span class="hljs-keyword">const</span> reference = seen.get(value)
                            <span class="hljs-keyword">if</span> (reference != <span class="hljs-literal">null</span>) {
                                replacements.set(value, <span class="hljs-string">'_reference'</span>)
                            } <span class="hljs-keyword">else</span> {
                                seen.set(value, path)
                                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) {
                                    <span class="hljs-keyword">const</span> array = []
                                    <span class="hljs-keyword">if</span> (
                                        <span class="hljs-keyword">typeof</span> value[<span class="hljs-number">0</span>] == <span class="hljs-string">'string'</span> &amp;&amp;
                                        <span class="hljs-regexp">/^_reference|_array|_undefined$/</span>.test(value[<span class="hljs-number">0</span>])
                                    ) {
                                        replacements.set(value, [ <span class="hljs-string">'_array'</span> ].concat(value))
                                    }
                                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span> &amp;&amp; ! (value <span class="hljs-keyword">instanceof</span> Interrupt &amp;&amp; value === object)) {
                                    <span class="hljs-keyword">const</span> error = { <span class="hljs-attr">message</span>: value.message }
                                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> value) {
                                        error[key] = value[key]
                                    }
                                    replacements.set(value, error)
                                } <span class="hljs-keyword">else</span> {
                                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> property <span class="hljs-keyword">in</span> value) {
                                        visit(path.concat(property), value[property])
                                    }
                                }
                            }
                        }
                    }
                <span class="hljs-keyword">default</span>:
                    <span class="hljs-keyword">return</span> value
                }
            }
            <span class="hljs-keyword">const</span> referenced = visit([], object)
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(referenced, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index, value</span>) </span>{
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'undefined'</span>) {
                    <span class="hljs-keyword">return</span> [ <span class="hljs-string">'_undefined'</span> ]
                }
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'function'</span> || <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'symbol'</span>) {
                    <span class="hljs-keyword">return</span> value.toString()
                }
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'object'</span> &amp;&amp; value != <span class="hljs-literal">null</span>) {
                    <span class="hljs-keyword">const</span> replacement = replacements.get(value)
                    <span class="hljs-keyword">if</span> (replacement != <span class="hljs-literal">null</span>) {
                        <span class="hljs-keyword">if</span> (replacement === <span class="hljs-string">'_reference'</span>) {
                            <span class="hljs-keyword">const</span> path = seen.get(value)
                            <span class="hljs-keyword">const</span> origin = {
                                <span class="hljs-attr">object</span>: <span class="hljs-keyword">get</span>(object, path.slice(0, path.length - 1)),
                                index: path[path.length - 1]
                            }
                            if (origin.object === this &amp;&amp; origin.index === index) {
                                <span class="hljs-keyword">return</span> value
                            }
                            <span class="hljs-keyword">return</span> [ <span class="hljs-string">'_reference'</span>, path ]
                        }
                        <span class="hljs-keyword">return</span> replacement
                    }
                }
                <span class="hljs-keyword">return</span> value
            }, <span class="hljs-number">4</span>)
        },</pre></div></div>

        </li>


        <li id="section-27">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Parse converts our escaped <code>Array</code> and <code>undefined</code> place holders and
builds an array of references in the reviver. It resolve the
references after parsing so that any referenced arrays are already
converted.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        parse (json) {
            <span class="hljs-keyword">const</span> references = []
            <span class="hljs-keyword">const</span> parsed = [ <span class="hljs-built_in">JSON</span>.parse(json) ]
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visit</span> (<span class="hljs-params">object, index, value</span>) </span>{
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'object'</span> &amp;&amp; value != <span class="hljs-literal">null</span>) {
                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) {
                        <span class="hljs-keyword">switch</span> (value[<span class="hljs-number">0</span>]) {
                        <span class="hljs-keyword">case</span> <span class="hljs-string">'_reference'</span>:
                            references.push({ object, index, <span class="hljs-attr">path</span>: value[<span class="hljs-number">1</span>] })
                            <span class="hljs-keyword">break</span>
                        <span class="hljs-keyword">case</span> <span class="hljs-string">'_undefined'</span>:
                            object[index] = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>
                            <span class="hljs-keyword">break</span>
                        <span class="hljs-keyword">case</span> <span class="hljs-string">'_array'</span>:
                            value.shift()
                        <span class="hljs-keyword">default</span>:
                            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, I = value.length; i &lt; I; i++) {
                                visit(value, i, value[i])
                            }
                        }
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> property <span class="hljs-keyword">in</span> value) {
                            visit(value, property, value[property])
                        }
                    }
                }
            }
            visit(parsed, <span class="hljs-number">0</span>, parsed[<span class="hljs-number">0</span>])
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> { object, index, path } <span class="hljs-keyword">of</span> references) {
                object[index] = <span class="hljs-keyword">get</span>(parsed[0], path)
            }
            return parsed[0]
        }
    }

    static Code (object) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.defineProperties({}, {
            <span class="hljs-attr">code</span>: { <span class="hljs-attr">value</span>: object.code, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span> },
            <span class="hljs-attr">symbol</span>: { <span class="hljs-attr">value</span>: object.symbol, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span> }
        })
    }</pre></div></div>

        </li>


        <li id="section-28">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-29">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>This constructor is only called by derived class and should not be called
by the user. An argument could be made that we accommodate the user that
hasn’t read the documentation because they could be calling this in
production having never tested an exceptional branch of their code, but
they could just as easily have misspelled <code>Interrupt</code>. Basically, we’re
not going to be as accommodating as all that.</p>

            </div>

        </li>


        <li id="section-30">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">constructor</span> (Protected, Class, Prototype, vargs) {</pre></div></div>

        </li>


        <li id="section-31">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>We can’t use <code>Interrupt.Error.assert</code> because auditing will make us
blow the stack.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        assert(PROTECTED === Protected, <span class="hljs-string">'INVALID_ACCESS'</span>)</pre></div></div>

        </li>


        <li id="section-32">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>When called with no arguments we call our super constructor with no
arguments to eventually call <code>Error</code> with no argments to create an
empty error.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">const</span> args = Class.options.apply(Class, vargs)
        <span class="hljs-keyword">const</span> prototypes = [ Prototype.prototypes[args.code] || { <span class="hljs-attr">code</span>: <span class="hljs-literal">null</span> } ]
        <span class="hljs-keyword">const</span> code = prototypes[<span class="hljs-number">0</span>].code
        <span class="hljs-keyword">if</span> (prototypes[<span class="hljs-number">0</span>].code != <span class="hljs-literal">null</span> &amp;&amp; prototypes[<span class="hljs-number">0</span>].code != args.code) {
            <span class="hljs-keyword">let</span> superPrototype = prototypes[<span class="hljs-number">0</span>], superCode
            <span class="hljs-keyword">do</span> {
                superCode = superPrototype.code
                superPrototype = Prototype.prototypes[superCode]
                prototypes.unshift(superPrototype)
            } <span class="hljs-keyword">while</span> (superPrototype.code != superCode)
        }
        prototypes.push(args, { <span class="hljs-attr">code</span>: prototypes[prototypes.length - <span class="hljs-number">1</span>].code })
        <span class="hljs-keyword">const</span> options = Class.options.apply(Class, prototypes)

        <span class="hljs-keyword">const</span> properties = {
            <span class="hljs-attr">name</span>: {</pre></div></div>

        </li>


        <li id="section-33">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p><strong>TODO</strong> Class.name?</p>

            </div>

            <div class="content"><div class='highlight'><pre>                value: Prototype.name,
                <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
                <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>
            },
            <span class="hljs-attr">errors</span>: {
                <span class="hljs-attr">value</span>: options.errors,
                <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
                <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>
            }
        }

        <span class="hljs-keyword">if</span> (options.code) {
            properties.code = {
                <span class="hljs-attr">value</span>: options.code,
                <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,
                <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>
            }
            properties.symbol = {
                <span class="hljs-attr">value</span>: Prototype.prototypes[options.code].symbol,
                <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
                <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>
            }
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> property <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.getOwnPropertyNames(options)) {
            <span class="hljs-keyword">if</span> (property[<span class="hljs-number">0</span>] != <span class="hljs-string">'_'</span> &amp;&amp; property[<span class="hljs-number">0</span>] != <span class="hljs-string">'#'</span> &amp;&amp; !<span class="hljs-regexp">/^(?:name|message|stack|symbol)$/</span>.test(property) &amp;&amp; !(property <span class="hljs-keyword">in</span> properties)) {
                properties[property] = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(options, property)
            }
        }</pre></div></div>

        </li>


        <li id="section-34">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p><strong>TODO</strong> Maybe option errors are in a weak map?</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">const</span> instance = { <span class="hljs-attr">message</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">errors</span>: options[<span class="hljs-string">'#errors'</span>], options, <span class="hljs-attr">displayed</span>: {} }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> property <span class="hljs-keyword">in</span> properties) {
            <span class="hljs-keyword">if</span> (properties[property].enumerable) {
                instance.displayed[property] = properties[property].value
            }
        }

        <span class="hljs-keyword">const</span> stackTraceLimit = <span class="hljs-built_in">Error</span>.stackTraceLimit
        <span class="hljs-keyword">if</span> (options[<span class="hljs-string">'#stack'</span>] != <span class="hljs-literal">null</span>) {
            <span class="hljs-built_in">Error</span>.stackTraceLimit = options[<span class="hljs-string">'#stack'</span>]
        }</pre></div></div>

        </li>


        <li id="section-35">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p><strong>TODO</strong> Display internal errors.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (
            options.code == <span class="hljs-literal">null</span> &amp;&amp;
            options.message == <span class="hljs-literal">null</span> &amp;&amp;
            options.errors.length == <span class="hljs-number">0</span> &amp;&amp;
            <span class="hljs-built_in">Object</span>.keys(options).filter(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> !<span class="hljs-regexp">/^#|^errors$/</span>.test(name)).length == <span class="hljs-number">0</span>
        ) {
            <span class="hljs-keyword">super</span>()
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">super</span>(context(options, instance))
        }

        Instances.set(<span class="hljs-keyword">this</span>, instance)

        <span class="hljs-built_in">Object</span>.defineProperties(<span class="hljs-keyword">this</span>, properties)</pre></div></div>

        </li>


        <li id="section-36">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>FYI It is faster to use <code>Error.captureStackTrace</code> again than
it is to try to strip the stack frames created by <code>Error</code>
using a regular expression or string manipulation. You know
because you tried. Years later: Thanks for reminding me, I keep
coming back to experiment with it.</p>

            </div>

        </li>


        <li id="section-37">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (options[<span class="hljs-string">'#callee'</span>] != <span class="hljs-literal">null</span>) {
            <span class="hljs-built_in">Error</span>.captureStackTrace(<span class="hljs-keyword">this</span>, options[<span class="hljs-string">'#callee'</span>])
        }

        <span class="hljs-built_in">Error</span>.stackTraceLimit = stackTraceLimit
    }</pre></div></div>

        </li>


        <li id="section-38">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>We ignore the depth and options. We’re not going to limit the output nor
sprinkle it with colors, not now and probably not ever. This was the
output we got before <code>util.inspect</code> added the enumberable <code>Error</code>
properties to its output.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    [util.inspect.custom](depth, options) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stack
    }</pre></div></div>

        </li>


        <li id="section-39">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>Our <code>toString</code> representation mirrors that of Node.js. We remove the
context and headings from the <code>message</code> used to generate <code>stack</code>.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    toString () {
        <span class="hljs-keyword">const</span> instance = Instances.get(<span class="hljs-keyword">this</span>)
        <span class="hljs-keyword">if</span> (instance.message == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name
        }
        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.name}</span>: <span class="hljs-subst">${instance.message}</span>`</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">get</span> OPTIONS () {
        <span class="hljs-keyword">return</span> OPTIONS
    }

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">get</span> CURRY () {
        <span class="hljs-keyword">return</span> { <span class="hljs-string">'#type'</span>: OPTIONS }
    }</pre></div></div>

        </li>


        <li id="section-40">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p><strong>TODO</strong> Wouldn’t it be nice to have some sort of way to specify
properties by code? Like which subsystem or a severity?</p>

            </div>

        </li>


        <li id="section-41">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">static</span> create (name, ...vargs) {
        <span class="hljs-keyword">const</span> SuperClass = <span class="hljs-keyword">typeof</span> vargs[<span class="hljs-number">0</span>] == <span class="hljs-string">'function'</span> ? vargs.shift() : Interrupt

        <span class="hljs-keyword">if</span> (Interrupt.Error != <span class="hljs-literal">null</span>) {
            assert(SuperClass === Interrupt || SuperClass.prototype <span class="hljs-keyword">instanceof</span> Interrupt, <span class="hljs-string">'INVALID_SUPER_CLASS'</span>, SuperClass.name)
        }

        <span class="hljs-keyword">const</span> Class = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SuperClass</span> </span>{
            <span class="hljs-keyword">constructor</span> (...vargs) {
                <span class="hljs-keyword">if</span> (vargs[<span class="hljs-number">0</span>] === PROTECTED) {
                    <span class="hljs-keyword">super</span>(...vargs)
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">super</span>(PROTECTED, Class, Prototype, vargs)
                }
            }

            <span class="hljs-keyword">static</span> <span class="hljs-keyword">get</span> codes () {
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(Prototype.codes)
            }

            <span class="hljs-keyword">static</span> code (code) {
                <span class="hljs-keyword">return</span> Prototype.codes[code]
            }

            <span class="hljs-keyword">static</span> options (...vargs) {
                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">attr</span> (<span class="hljs-params">value</span>) </span>{
                    <span class="hljs-keyword">return</span> { <span class="hljs-attr">value</span>: value, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span> }
                }
                <span class="hljs-keyword">const</span> options = {
                    <span class="hljs-string">'#type'</span>: attr(OPTIONS),
                    <span class="hljs-string">'#errors'</span>: attr([]),
                    <span class="hljs-attr">errors</span>: attr([]),
                    <span class="hljs-string">'#stack'</span>: attr(<span class="hljs-literal">null</span>),
                    <span class="hljs-string">'#callee'</span>: attr(<span class="hljs-literal">null</span>)
                }
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> argument <span class="hljs-keyword">of</span> vargs) {
                    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">typeof</span> argument) {
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'string'</span>: {</pre></div></div>

        </li>


        <li id="section-42">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p><strong>TODO</strong> Keep expecting us to use the first code that is set, but
we don’t do that, do we?</p>

            </div>

            <div class="content"><div class='highlight'><pre>                            <span class="hljs-keyword">if</span> (Prototype.prototypes[argument] != <span class="hljs-literal">null</span>) {
                                options.code = attr(argument)
                            } <span class="hljs-keyword">else</span> {
                                options.message = attr(argument)
                            }
                        }
                        <span class="hljs-keyword">break</span>
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'symbol'</span>: {</pre></div></div>

        </li>


        <li id="section-43">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p><strong>TODO</strong> Wondering about code overrides, should they be allowed?
Or do we accept the first code that is set?</p>

            </div>

            <div class="content"><div class='highlight'><pre>                            <span class="hljs-keyword">const</span> code = Prototype.symbols.get(argument)
                            <span class="hljs-keyword">if</span> (code != <span class="hljs-literal">null</span>) {
                                options.code = attr(code)
                            }
                        }
                        <span class="hljs-keyword">break</span>
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'number'</span>: {
                            <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">Number</span>.isInteger(argument) || argument == <span class="hljs-literal">Infinity</span>) &amp;&amp; argument &gt;= <span class="hljs-number">0</span>) {
                                options[<span class="hljs-string">'#stack'</span>] = attr(argument)
                            } <span class="hljs-keyword">else</span> {
                                options[<span class="hljs-string">'#errors'</span>].value.push(combine(Interrupt.Error.codes(<span class="hljs-string">'INVALID_PROPERTY_TYPE'</span>)))
                            }
                        }
                        <span class="hljs-keyword">break</span>
                    <span class="hljs-keyword">case</span> <span class="hljs-string">'object'</span>: {
                            <span class="hljs-keyword">if</span> (argument == <span class="hljs-literal">null</span>) {</pre></div></div>

        </li>


        <li id="section-44">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p><strong>TODO</strong> code = { text, symbol } // name? label? identifier? id? string?</p>

            </div>

            <div class="content"><div class='highlight'><pre>                                options[<span class="hljs-string">'#errors'</span>].push(combine(Interrupt.Error.codes(<span class="hljs-string">'NULL_ARGUMENT'</span>)))
                            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argument <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span>) {
                                options.errors.value.push(argument)
                            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(argument)) {
                                options.errors.value.push.apply(options.errors.value, argument)
                            } <span class="hljs-keyword">else</span> {
                                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> property <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.getOwnPropertyNames(argument)) {
                                    <span class="hljs-keyword">switch</span> (property) {
                                    <span class="hljs-keyword">case</span> <span class="hljs-string">'#type'</span>: {
                                            <span class="hljs-keyword">if</span> (argument[property] !== OPTIONS) {
                                                options[<span class="hljs-string">'#errors'</span>].value.push(combine(Interrupt.Error.codes(<span class="hljs-string">'INVALID_PROPERTY_TYPE'</span>), { property }))
                                            }
                                        }
                                        <span class="hljs-keyword">break</span>
                                    <span class="hljs-keyword">case</span> <span class="hljs-string">'#errors'</span>: {
                                            <span class="hljs-keyword">if</span> (
                                                <span class="hljs-built_in">Array</span>.isArray(argument[property]) &amp;&amp;
                                                argument[property].every(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
                                                    <span class="hljs-keyword">return</span> Interrupt.Error[error.code] === error.symbol
                                                })
                                            ) {
                                                options[<span class="hljs-string">'#errors'</span>].value.push.apply(options[<span class="hljs-string">'#errors'</span>].value, argument[property])
                                            } <span class="hljs-keyword">else</span> {
                                                options[<span class="hljs-string">'#errors'</span>].value.push(combine(Interrupt.Error.codes(<span class="hljs-string">'INVALID_PROPERTY_TYPE'</span>), { property }))
                                            }
                                        }
                                        <span class="hljs-keyword">break</span>
                                    <span class="hljs-keyword">case</span> <span class="hljs-string">'#stack'</span>: {
                                            <span class="hljs-keyword">const</span> stack = argument[property]
                                            <span class="hljs-keyword">if</span> (stack == <span class="hljs-literal">null</span>) {
                                            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">Number</span>.isInteger(stack) || stack == <span class="hljs-literal">Infinity</span>) &amp;&amp; stack &gt;= <span class="hljs-number">0</span>) {
                                                options[<span class="hljs-string">'#stack'</span>] = attr(stack)
                                            } <span class="hljs-keyword">else</span> {
                                                options[<span class="hljs-string">'#errors'</span>].value.push(combine(Interrupt.Error.codes(<span class="hljs-string">'INVALID_PROPERTY_TYPE'</span>), { property }))
                                            }
                                        }
                                        <span class="hljs-keyword">break</span>
                                    <span class="hljs-keyword">case</span> <span class="hljs-string">'stack'</span>:
                                    <span class="hljs-keyword">case</span> <span class="hljs-string">'name'</span>: {
                                            options[<span class="hljs-string">'#errors'</span>].value.push(combine(Interrupt.Error.codes(<span class="hljs-string">'INVALID_PROPERTY_NAME'</span>), { property }))
                                        }
                                        <span class="hljs-keyword">break</span>
                                    <span class="hljs-keyword">case</span> <span class="hljs-string">'errors'</span>: {
                                            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(argument[property])) {
                                                options.errors.value.push.apply(options.errors.value, argument[property])
                                            } <span class="hljs-keyword">else</span> {
                                                options[<span class="hljs-string">'#errors'</span>].value.push(combine(Interrupt.Error.codes(<span class="hljs-string">'INVALID_PROPERTY_TYPE'</span>), { property }))
                                            }
                                        }
                                        <span class="hljs-keyword">break</span>
                                    <span class="hljs-keyword">case</span> <span class="hljs-string">'message'</span>: {
                                            <span class="hljs-keyword">if</span> (argument[property] == <span class="hljs-literal">null</span>) {
                                            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> argument[property] === <span class="hljs-string">'string'</span>) {
                                                options.message = attr(argument[property])
                                            } <span class="hljs-keyword">else</span> {
                                                options[<span class="hljs-string">'#errors'</span>].value.push(combine(Interrupt.Error.codes(<span class="hljs-string">'INVALID_PROPERTY_TYPE'</span>), { property }))
                                            }
                                        }
                                        <span class="hljs-keyword">break</span>
                                    <span class="hljs-keyword">case</span> <span class="hljs-string">'code'</span>: {</pre></div></div>

        </li>


        <li id="section-45">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p><strong>TODO</strong> Convert <code>symbol</code> to <code>string</code>.</p>

            </div>

            <div class="content"><div class='highlight'><pre>                                            <span class="hljs-keyword">if</span> (argument[property] == <span class="hljs-literal">null</span>) {
                                            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> argument[property] === <span class="hljs-string">'string'</span>) {
                                                <span class="hljs-keyword">if</span> (Prototype.prototypes[argument[property]]) {
                                                    options.code = attr(argument[property])
                                                } <span class="hljs-keyword">else</span> {
                                                    options[<span class="hljs-string">'#errors'</span>].value.push(combine(Interrupt.Error.codes(<span class="hljs-string">'UNKNOWN_CODE'</span>), {
                                                        <span class="hljs-attr">property</span>: property,
                                                        <span class="hljs-attr">value</span>: argument[property]
                                                    }))
                                                }
                                            } <span class="hljs-keyword">else</span> {
                                                options[<span class="hljs-string">'#errors'</span>].value.push(combine(Interrupt.Error.code(<span class="hljs-string">'INVALID_PROPERTY_TYPE'</span>), { property }))
                                            }
                                        }
                                        <span class="hljs-keyword">break</span>
                                    <span class="hljs-keyword">case</span> <span class="hljs-string">'symbol'</span>: {
                                            <span class="hljs-keyword">if</span> (argument[property] == <span class="hljs-literal">null</span>) {
                                            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> argument[property] == <span class="hljs-string">'symbol'</span>) {
                                                <span class="hljs-keyword">const</span> code = Prototype.symbols.get(argument[property])
                                                <span class="hljs-keyword">if</span> (code != <span class="hljs-literal">null</span>) {
                                                    options.code = attr(code)
                                                } <span class="hljs-keyword">else</span> {
                                                    options[<span class="hljs-string">'#errors'</span>].value.push(combine(Interrupt.Error.codes(<span class="hljs-string">'UNKNOWN_CODE'</span>), {
                                                        <span class="hljs-attr">property</span>: property,
                                                        <span class="hljs-attr">value</span>: argument[property]
                                                    }))
                                                }
                                            } <span class="hljs-keyword">else</span> {
                                                options[<span class="hljs-string">'#errors'</span>].value.push(combine(Interrupt.Error.codes(<span class="hljs-string">'INVALID_PROPERTY_TYPE'</span>), { property }))
                                            }
                                        }
                                        <span class="hljs-keyword">break</span>
                                    <span class="hljs-keyword">case</span> <span class="hljs-string">'#callee'</span>: {
                                            <span class="hljs-keyword">if</span> (argument[property] == <span class="hljs-literal">null</span>) {
                                            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> argument[property] == <span class="hljs-string">'function'</span>) {
                                                options[property] = attr(argument[property])
                                            } <span class="hljs-keyword">else</span> {
                                                options[<span class="hljs-string">'#errors'</span>].value.push(combine(Interrupt.Error.codes(<span class="hljs-string">'INVALID_PROPERTY_TYPE'</span>), { property }))
                                            }
                                        }
                                        <span class="hljs-keyword">break</span>
                                    <span class="hljs-keyword">default</span>: {
                                            <span class="hljs-keyword">if</span> (!RE.identifier.test(property) &amp;&amp; property != <span class="hljs-string">'#stack'</span>) {
                                                options[<span class="hljs-string">'#errors'</span>].value.push(combine(Interrupt.Error.code(<span class="hljs-string">'INVALID_PROPERTY_NAME'</span>), { property }))
                                            } <span class="hljs-keyword">else</span> {
                                                options[property] = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(argument, property)
                                            }
                                        }
                                        <span class="hljs-keyword">break</span>
                                    }
                                }
                            }
                        }
                    }
                }
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.defineProperties({}, options)
            }

            <span class="hljs-keyword">static</span> assert (...vargs) {
                <span class="hljs-keyword">return</span> _assert(Class.assert, {}, vargs)
            }

            <span class="hljs-keyword">static</span> invoke (...vargs) {
                <span class="hljs-keyword">return</span> _invoke(Class.invoke, {}, vargs)
            }

            <span class="hljs-keyword">static</span> callback (...vargs) {
                <span class="hljs-keyword">return</span> _callback(Class.callback, {}, vargs)
            }

            <span class="hljs-keyword">static</span> resolve (...vargs) {
                <span class="hljs-keyword">return</span> _resolver(Class.resolve, {}, vargs)
            }
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">construct</span> (<span class="hljs-params">options, vargs, errors, ...callees</span>) </span>{
            <span class="hljs-keyword">const</span> error = _construct(options, vargs, errors, callees)
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> Interrupt.audit === <span class="hljs-string">'function'</span>) {
                Interrupt.audit(error, Instances.get(error).errors)
            }
            <span class="hljs-keyword">return</span> error
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_construct</span> (<span class="hljs-params">options, vargs, errors, callees</span>) </span>{
            <span class="hljs-keyword">if</span> (vargs.length === <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-keyword">typeof</span> vargs[<span class="hljs-number">0</span>] == <span class="hljs-string">'function'</span>) {
                <span class="hljs-keyword">let</span> called = <span class="hljs-literal">false</span>
                <span class="hljs-keyword">const</span> f = vargs.pop()
                <span class="hljs-keyword">const</span> merged = Class.options({ <span class="hljs-string">'#callee'</span>: callees[<span class="hljs-number">1</span>] || $ }, options)
                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">$</span> (<span class="hljs-params">...vargs</span>) </span>{
                    called = <span class="hljs-literal">true</span>
                    <span class="hljs-keyword">const</span> options = Class.options.apply(Class, [ merged ].concat(vargs, { errors }))
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Class(options)
                }
                <span class="hljs-keyword">const</span> error = f($)
                <span class="hljs-keyword">if</span> (!called) {
                    <span class="hljs-keyword">const</span> error = <span class="hljs-keyword">new</span> Class
                    <span class="hljs-keyword">const</span> instance = Instances.get(error)
                    instance.errors.push({
                        <span class="hljs-attr">code</span>: Interrupt.Error.DEFERRED_CONSTRUCTOR_NOT_CALLED
                    })
                    <span class="hljs-keyword">return</span> error
                }
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> error != <span class="hljs-string">'object'</span> || error == <span class="hljs-literal">null</span> || !(error <span class="hljs-keyword">instanceof</span> Class)) {
                    <span class="hljs-keyword">const</span> error = <span class="hljs-keyword">new</span> Class
                    <span class="hljs-keyword">const</span> instance = Instances.get(error)
                    instance.errors.push({
                        <span class="hljs-attr">code</span>: Interrupt.Error.DEFERRED_CONSTRUCTOR_INVALID_RETURN
                    })
                    <span class="hljs-keyword">return</span> error
                }
                <span class="hljs-keyword">return</span> error
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Class(Class.options.apply(Class, [{ <span class="hljs-string">'#callee'</span>: callees[<span class="hljs-number">0</span>] }, options ].concat(vargs, { errors })))
            }
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_assert</span> (<span class="hljs-params">callee, options, vargs</span>) </span>{
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> vargs[<span class="hljs-number">0</span>] === <span class="hljs-string">'object'</span> &amp;&amp; vargs[<span class="hljs-number">0</span>][<span class="hljs-string">'#type'</span>] === OPTIONS) {
                <span class="hljs-keyword">const</span> merged = Class.options.apply(Class, [ options ].concat(vargs))
                <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assert</span> (<span class="hljs-params">...vargs</span>) </span>{
                    _assert(assert, merged, vargs)
                }
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!vargs[<span class="hljs-number">0</span>]) {
                vargs.shift()
                <span class="hljs-keyword">throw</span> construct(options, vargs, [], callee, callee)
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> Interrupt.audit == <span class="hljs-string">'function'</span>) {
                construct(options, vargs, [], callee, callee)
            }
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_invoke</span> (<span class="hljs-params">callee, options, vargs</span>) </span>{
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> vargs[<span class="hljs-number">0</span>] == <span class="hljs-string">'function'</span>) {
                <span class="hljs-keyword">const</span> f = vargs.shift()
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-keyword">const</span> result = f()
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> Interrupt.audit === <span class="hljs-string">'function'</span>) {
                        construct(options, vargs, [ AUDIT ], callee, callee)
                    }
                    <span class="hljs-keyword">return</span> result
                } <span class="hljs-keyword">catch</span> (error) {
                    <span class="hljs-keyword">throw</span> construct(options, vargs, [ error ], callee, callee)
                }
            }
            <span class="hljs-keyword">const</span> merged = Class.options.apply(Class, [ options ].concat(vargs))
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invoker</span> (<span class="hljs-params">...vargs</span>) </span>{
                <span class="hljs-keyword">return</span> _invoke(invoker, merged, vargs)
            }
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_callback</span> (<span class="hljs-params">callee, options, vargs</span>) </span>{
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> vargs[<span class="hljs-number">0</span>] == <span class="hljs-string">'function'</span>) {</pre></div></div>

        </li>


        <li id="section-46">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p><strong>TODO</strong> Assert constructor is a function.</p>

            </div>

            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">const</span> [ <span class="hljs-keyword">constructor</span>, callback ] = vargs
                return function (...vargs) {
                    <span class="hljs-keyword">if</span> (vargs[<span class="hljs-number">0</span>] == <span class="hljs-literal">null</span>) {
                        callback.apply(<span class="hljs-literal">null</span>, vargs)
                        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> Interrupt.audit == <span class="hljs-string">'function'</span>) {
                            construct(options, [ <span class="hljs-keyword">constructor</span> ], [ AUDIT ])
                        }
                    } else {
                        callback(construct(options, [ <span class="hljs-keyword">constructor</span> ], [ vargs[0] ]))
                    }
                }
            }
            const merged = Class.options.apply(Class, [ options ].concat(vargs))
            return function wrapper (...vargs) {
                <span class="hljs-keyword">return</span> _callback(wrapper, merged, vargs)
            }
        }

        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span> (<span class="hljs-params">callee, f, options, vargs</span>) </span>{
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> f == <span class="hljs-string">'function'</span>) {
                    f = f()
                }
                <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> f
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> Interrupt.audit == <span class="hljs-string">'function'</span>) {
                    construct(options, vargs, [ AUDIT ], callee)
                }
                <span class="hljs-keyword">return</span> result
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">throw</span> construct(options, vargs, [ error ], callee)
            }
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_resolver</span> (<span class="hljs-params">callee, options, vargs</span>) </span>{
            <span class="hljs-keyword">if</span> (
                <span class="hljs-keyword">typeof</span> vargs[<span class="hljs-number">0</span>] == <span class="hljs-string">'function'</span> ||
                (
                    <span class="hljs-keyword">typeof</span> vargs[<span class="hljs-number">0</span>] == <span class="hljs-string">'object'</span> &amp;&amp;
                    vargs[<span class="hljs-number">0</span>] != <span class="hljs-literal">null</span> &amp;&amp;
                    <span class="hljs-keyword">typeof</span> vargs[<span class="hljs-number">0</span>].then == <span class="hljs-string">'function'</span>
                )
            ) {
                <span class="hljs-keyword">return</span> resolve(callee, vargs.shift(), options, vargs)
            }
            <span class="hljs-keyword">const</span> merged = Class.options.apply(Class, [ options ].concat(vargs))
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolver</span> (<span class="hljs-params">...vargs</span>) </span>{
                <span class="hljs-keyword">return</span> _resolver(resolver, merged, vargs)
            }
        }

        <span class="hljs-built_in">Object</span>.defineProperty(Class, <span class="hljs-string">'name'</span>, { <span class="hljs-attr">value</span>: name })</pre></div></div>

        </li>


        <li id="section-47">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>We have an prototypical state of an exception that we do not want to
store in the class and we definitely do not want to expose it
publicly.</p>

            </div>

        </li>


        <li id="section-48">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>Running out of names, must tidy.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">const</span> SuperPrototype = Prototypes.get(SuperClass)
        <span class="hljs-keyword">const</span> Prototype = {
            <span class="hljs-attr">name</span>: name,
            <span class="hljs-attr">is</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>,
            <span class="hljs-attr">symbols</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>,
            <span class="hljs-attr">codes</span>: {},
            <span class="hljs-attr">prototypes</span>: {},
            <span class="hljs-attr">Super</span>: { <span class="hljs-attr">Codes</span>: {}, <span class="hljs-attr">Aliases</span>: {} }
        }
        Prototypes.set(Class, Prototype)</pre></div></div>

        </li>


        <li id="section-49">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>Detect duplicate declarations.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">const</span> duplicates = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>

        <span class="hljs-keyword">while</span> (vargs.length != <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">const</span> codes = vargs.shift()
            <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">typeof</span> codes) {</pre></div></div>

        </li>


        <li id="section-50">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>Define a code with no default properties.</p>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">case</span> <span class="hljs-string">'string'</span>: {
                    <span class="hljs-keyword">const</span> object = {}
                    object[codes] = <span class="hljs-literal">null</span>
                    vargs.unshift(object)
                    <span class="hljs-keyword">continue</span>
                }</pre></div></div>

        </li>


        <li id="section-51">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>Invoke a function that will return further code definitions.</p>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">case</span> <span class="hljs-string">'function'</span>: {
                    vargs.unshift(codes({ <span class="hljs-attr">Codes</span>: Prototype.Super.Codes, <span class="hljs-attr">Super</span>: SuperPrototype.Super }))
                    <span class="hljs-keyword">continue</span>
                }</pre></div></div>

        </li>


        <li id="section-52">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>If an array, unshift the definitions onto our argument list,
otherwise fall through to object processing.</p>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">case</span> <span class="hljs-string">'object'</span>: {
                    assert(codes != <span class="hljs-literal">null</span>, <span class="hljs-string">'INVALID_ARGUMENT'</span>)
                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(codes)) {
                        vargs.unshift.apply(vargs, codes)
                        <span class="hljs-keyword">continue</span>
                    }
                    <span class="hljs-keyword">if</span> (SuperPrototype.is.has(codes)) {
                        <span class="hljs-keyword">const</span> object = {}
                        object[codes.code] = SuperPrototype.prototypes[codes.code]
                        vargs.unshift(object)
                        <span class="hljs-keyword">continue</span>
                    }
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> code <span class="hljs-keyword">in</span> codes) {</pre></div></div>

        </li>


        <li id="section-53">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>Duplicate declaration detection. <strong>TODO</strong> Better error.</p>

            </div>

            <div class="content"><div class='highlight'><pre>                        assert(!duplicates.has(code), <span class="hljs-string">'DUPLICATE_CODE'</span>, { code })
                        duplicates.add(code)</pre></div></div>

        </li>


        <li id="section-54">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>Use an existing code symbol from the super class if one exists,
otherwise create a new symbol.</p>

            </div>

            <div class="content"><div class='highlight'><pre>
                        <span class="hljs-keyword">const</span> object = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                            <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">typeof</span> codes[code]) {
                            <span class="hljs-keyword">case</span> <span class="hljs-string">'symbol'</span>: {</pre></div></div>

        </li>


        <li id="section-55">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p><strong>TODO</strong> This is new, what about it?</p>

            </div>

            <div class="content"><div class='highlight'><pre>                                    <span class="hljs-keyword">return</span> { code, <span class="hljs-attr">symbol</span>: codes[code] }
                                }
                            <span class="hljs-keyword">case</span> <span class="hljs-string">'string'</span>: {
                                    <span class="hljs-keyword">return</span> { <span class="hljs-attr">message</span>: codes[code] }
                                }
                            <span class="hljs-keyword">case</span> <span class="hljs-string">'object'</span>: {
                                    <span class="hljs-keyword">if</span> (codes[code] == <span class="hljs-literal">null</span>) {
                                        <span class="hljs-keyword">return</span> {}
                                    }
                                    <span class="hljs-keyword">return</span> codes[code]
                                }
                            <span class="hljs-keyword">default</span>:
                                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>
                            }
                        } ()</pre></div></div>

        </li>


        <li id="section-56">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>Goes here.</p>

            </div>

            <div class="content"><div class='highlight'><pre>                        <span class="hljs-keyword">const</span> prototype = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</pre></div></div>

        </li>


        <li id="section-57">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p><strong>TODO</strong> Kind of broken. What if the user uses a key other than
the existing code? Turn <code>is</code> into map and use the existing code,
I guess.</p>

            </div>

            <div class="content"><div class='highlight'><pre>                            <span class="hljs-keyword">if</span> (SuperPrototype.is.has(object)) {
                                <span class="hljs-keyword">return</span> object
                            }
                            <span class="hljs-keyword">if</span> (object == <span class="hljs-literal">null</span>) {
                                <span class="hljs-keyword">return</span> { code }
                            }
                            <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">typeof</span> coalesce(object.code)) {
                            <span class="hljs-keyword">case</span> <span class="hljs-string">'symbol'</span>: {</pre></div></div>

        </li>


        <li id="section-58">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>Create an alias of the specified <code>code</code>. When creating an alias,
specifying a <code>symbol</code> is not allowed.</p>

            </div>

            <div class="content"><div class='highlight'><pre>                                    <span class="hljs-keyword">const</span> code = Prototype.symbols.get(object.code)
                                    assert(code != <span class="hljs-literal">null</span>, <span class="hljs-string">'INVALID_CODE'</span>)
                                    <span class="hljs-keyword">return</span> combine(object, { <span class="hljs-attr">code</span>: code })
                                }
                            <span class="hljs-keyword">case</span> <span class="hljs-string">'string'</span>: {</pre></div></div>

        </li>


        <li id="section-59">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>If the code in the object matches the used as the key, that’s
exactly the form we use for the prototype, otherwise we’re
creating an alias.</p>

            </div>

            <div class="content"><div class='highlight'><pre>                                    <span class="hljs-keyword">if</span> (object.code == code) {
                                        <span class="hljs-keyword">return</span> object
                                    }
                                    assert(Prototype.prototypes[object.code] != <span class="hljs-literal">null</span>, <span class="hljs-string">'INVALID_CODE'</span>)
                                    <span class="hljs-keyword">return</span> object
                                }
                            <span class="hljs-keyword">case</span> <span class="hljs-string">'object'</span>: {</pre></div></div>

        </li>


        <li id="section-60">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>No alias, set the code to key from the set of aliases.</p>

            </div>

            <div class="content"><div class='highlight'><pre>                                    <span class="hljs-keyword">if</span> (object.code == <span class="hljs-literal">null</span>) {
                                        <span class="hljs-keyword">return</span> combine(object, { code })
                                    }</pre></div></div>

        </li>


        <li id="section-61">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>Define an alias extending on the given code or alias.</p>

            </div>

            <div class="content"><div class='highlight'><pre>                                    <span class="hljs-keyword">const</span> superSuperCode = SuperPrototype.is.get(object.code)
                                    <span class="hljs-keyword">if</span> (superSuperCode != <span class="hljs-literal">null</span>) {
                                        <span class="hljs-keyword">if</span> (superSuperCode === object.code.code) {
                                            assert(superSuperCode == code, <span class="hljs-string">'INVALID_CODE'</span>)
                                            <span class="hljs-keyword">return</span> combine(object.code, object, { <span class="hljs-attr">code</span>: code })
                                        } <span class="hljs-keyword">else</span> {
                                            <span class="hljs-keyword">return</span> combine(object.code, object, { <span class="hljs-attr">code</span>: code, <span class="hljs-attr">symbol</span>: <span class="hljs-literal">null</span> })
                                        }
                                    }
                                    <span class="hljs-keyword">const</span> superCode = Prototype.is.get(object.code)
                                    assert(superCode != <span class="hljs-literal">null</span>, <span class="hljs-string">'INVALID_CODE'</span>)</pre></div></div>

        </li>


        <li id="section-62">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>Must be an alias.</p>

            </div>

            <div class="content"><div class='highlight'><pre>                                    <span class="hljs-keyword">return</span> combine(object.code, object, { <span class="hljs-attr">symbol</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">code</span>: object.code.code })
                                }
                            <span class="hljs-keyword">default</span>:
                                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'INVALID_CODE'</span>)
                            }
                        } ()

                        <span class="hljs-keyword">if</span> (prototype.message == <span class="hljs-literal">null</span>) {
                            prototype.message = prototype.code
                        }
                        <span class="hljs-keyword">if</span> (prototype.code == code) {
                            <span class="hljs-keyword">if</span> (prototype.symbol == <span class="hljs-literal">null</span>) {
                                prototype.symbol = <span class="hljs-built_in">Symbol</span>(code)
                            }</pre></div></div>

        </li>


        <li id="section-63">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>Create a property to hold the symbol in the class.</p>

            </div>

            <div class="content"><div class='highlight'><pre>                            <span class="hljs-built_in">Object</span>.defineProperty(Class, code, { <span class="hljs-attr">value</span>: prototype.symbol })</pre></div></div>

        </li>


        <li id="section-64">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>Our internal tracking of symbols.</p>

            </div>

            <div class="content"><div class='highlight'><pre>                            Prototype.symbols.set(prototype.symbol, code)

                            Prototype.codes[code] = <span class="hljs-built_in">Object</span>.defineProperties({}, {
                                <span class="hljs-attr">code</span>: { <span class="hljs-attr">value</span>: code, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span> },
                                <span class="hljs-attr">symbol</span>: { <span class="hljs-attr">value</span>: prototype.symbol }
                            })

                            Prototype.Super.Codes[code] = prototype
                        } <span class="hljs-keyword">else</span> {
                            assert(Prototype.prototypes[prototype.code], <span class="hljs-string">'SUPER_PROTOTYPE_MISSING'</span>, {
                                <span class="hljs-attr">definition</span>: { <span class="hljs-attr">superCode</span>: prototype.code, <span class="hljs-attr">code</span>: code }
                            })
                            assert(prototype.symbol == <span class="hljs-literal">null</span>, <span class="hljs-string">'SYMBOLS_NOT_ALLOWED'</span>, {
                                <span class="hljs-attr">definition</span>: { <span class="hljs-attr">symbol</span>: <span class="hljs-built_in">String</span>(prototype.symbol), <span class="hljs-attr">superCode</span>: prototype.code, <span class="hljs-attr">code</span>: code }
                            })
                            Prototype.Super.Aliases[code] = prototype
                        }
                        Prototype.prototypes[code] = prototype
                        Prototype.is.set(prototype, code)
                    }
                }
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">default</span>:
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Interrupt.Error(<span class="hljs-string">'INVALID_ARGUMENT'</span>)
            }
        }

        <span class="hljs-keyword">return</span> Class
    }</pre></div></div>

        </li>


        <li id="section-65">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>Get just the message for the given Interrupt error.</p>
<p>If the error is not an Interrupt error return the <code>message</code> property of
the error or <code>null</code> if the property is not defined.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">static</span> message (error) {
        <span class="hljs-keyword">const</span> instance = Instances.get(error)
        <span class="hljs-keyword">if</span> (instance != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> instance.message
        }
        <span class="hljs-keyword">return</span> coalesce(error.message)
    }

    <span class="hljs-keyword">static</span> parse (stack) {
        <span class="hljs-keyword">const</span> parser = <span class="hljs-keyword">new</span> Interrupt.Parser
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> line <span class="hljs-keyword">of</span> stack.split(<span class="hljs-string">'\n'</span>)) {
            parser.push(line)
        }
        parser.end()
        <span class="hljs-keyword">return</span> parser._node
    }

    <span class="hljs-keyword">static</span> dedup (error, keyify = <span class="hljs-function">(<span class="hljs-params">_, file, line</span>) =&gt;</span> [ file, line ]) {
        <span class="hljs-keyword">const</span> seen = {}
        <span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">treeify</span> (<span class="hljs-params">parent, error</span>) </span>{
            <span class="hljs-keyword">const</span> [ file, line ] = location(error.stack)
            <span class="hljs-keyword">const</span> key = keyify(error, file, line)
            <span class="hljs-keyword">if</span> (error <span class="hljs-keyword">instanceof</span> Interrupt) {
                <span class="hljs-keyword">const</span> node = {
                    <span class="hljs-attr">parent</span>: parent,
                    <span class="hljs-attr">duplicated</span>: <span class="hljs-literal">false</span>,
                    <span class="hljs-attr">duplicates</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>,
                    <span class="hljs-attr">id</span>: id++,
                    <span class="hljs-attr">key</span>: key,
                    <span class="hljs-attr">stringified</span>: Keyify.stringify(key),
                    <span class="hljs-attr">context</span>: {}, <span class="hljs-comment">// **TODO** Legacy, dubious.</span>
                    error: error,
                    <span class="hljs-attr">errors</span>: <span class="hljs-literal">null</span>
                }
                node.errors = error.errors.map(<span class="hljs-function">(<span class="hljs-params">cause, index</span>) =&gt;</span> {
                    <span class="hljs-keyword">return</span> treeify(node, cause)
                })
                <span class="hljs-keyword">return</span> node
            }
            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">parent</span>: parent,
                <span class="hljs-attr">duplicated</span>: <span class="hljs-literal">false</span>,
                <span class="hljs-attr">id</span>: id++,
                <span class="hljs-attr">key</span>: key,
                <span class="hljs-attr">duplicates</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>,
                <span class="hljs-attr">stringified</span>: Keyify.stringify(key),
                <span class="hljs-attr">error</span>: error,
                <span class="hljs-attr">context</span>: {},
                <span class="hljs-attr">errors</span>: <span class="hljs-literal">null</span>
            }
        }
        <span class="hljs-keyword">const</span> leaves = {}
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">leafify</span> (<span class="hljs-params">node</span>) </span>{
            <span class="hljs-keyword">if</span> (node.errors != <span class="hljs-literal">null</span> &amp;&amp; node.errors.length != <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> cause <span class="hljs-keyword">of</span> node.errors) {
                    leafify(cause)
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">const</span> key = node.stringified
                <span class="hljs-keyword">if</span> (leaves[key] == <span class="hljs-literal">null</span>) {
                    leaves[key] = []
                }
                leaves[key].push(node)
            }
        }
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compare</span> (<span class="hljs-params">left, right</span>) </span>{
            <span class="hljs-keyword">if</span> (left.stringified != right.stringified) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
            }
            <span class="hljs-keyword">if</span> (left.errors == <span class="hljs-literal">null</span> &amp;&amp; right.errors == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
            }
            <span class="hljs-keyword">if</span> (left.errors.length != right.errors.length) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
            }
            <span class="hljs-keyword">const</span> errors = right.errors.slice(<span class="hljs-number">0</span>)
            CAUSES: <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> cause <span class="hljs-keyword">of</span> left.errors) {
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; errors.length; i++) {
                    <span class="hljs-keyword">if</span> (compare(cause, errors[i])) {
                        errors.splice(i, <span class="hljs-number">1</span>)
                        <span class="hljs-keyword">continue</span> CAUSES
                    }
                }
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
        }
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mark</span> (<span class="hljs-params">node</span>) </span>{
            <span class="hljs-keyword">if</span> (node.duplicated) {
                <span class="hljs-keyword">return</span>
            }
            <span class="hljs-keyword">if</span> (node.errors != <span class="hljs-literal">null</span> &amp;&amp; node.errors.length != <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> cause <span class="hljs-keyword">of</span> node.errors) {
                    mark(cause)
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> other <span class="hljs-keyword">of</span> leaves[node.stringified]) {
                    <span class="hljs-keyword">if</span> (other === node) {
                        <span class="hljs-keyword">continue</span>
                    }
                    <span class="hljs-keyword">const</span> iterator = {
                        <span class="hljs-attr">self</span>: node,
                        <span class="hljs-attr">other</span>: other
                    }
                    <span class="hljs-keyword">const</span> departure = {
                        <span class="hljs-attr">self</span>: <span class="hljs-literal">null</span>,
                        <span class="hljs-attr">other</span>: <span class="hljs-literal">null</span>
                    }
                    <span class="hljs-keyword">while</span> (
                        iterator.self.parent != <span class="hljs-literal">null</span> &amp;&amp;
                        iterator.other.parent != <span class="hljs-literal">null</span> &amp;&amp;
                        iterator.self !== iterator.other &amp;&amp;
                        iterator.self.parent.stringified == iterator.other.parent.stringified
                    ) {
                        departure.self = iterator.self
                        departure.other = iterator.other
                        iterator.self = iterator.self.parent
                        iterator.other = iterator.other.parent
                    }
                    <span class="hljs-keyword">if</span> (departure.self != <span class="hljs-literal">null</span>) {
                        <span class="hljs-keyword">if</span> (compare(departure.self, departure.other)) {
                            departure.self.duplicates.add(departure.other.id)
                            departure.other.duplicated = <span class="hljs-literal">true</span>
                        }
                    }
                }
            }
        }
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">format</span> (<span class="hljs-params">node</span>) </span>{
            <span class="hljs-keyword">if</span> (node.errors == <span class="hljs-literal">null</span> || node.errors.length == <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">const</span> repeated = node.duplicates.size + <span class="hljs-number">1</span>
                <span class="hljs-keyword">const</span> context = node.context
                <span class="hljs-keyword">if</span> (repeated != <span class="hljs-number">1</span>) {
                    context.repeated = repeated
                }
                <span class="hljs-keyword">const</span> text = (node.error <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span>)
                    ? coalesce(node.error.stack, node.error.message)
                    : node.error.toString()
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.keys(context).length != <span class="hljs-number">0</span>) {
                    <span class="hljs-keyword">const</span> contextualized = Interrupt.JSON.stringify(context)
                    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${contextualized}</span>\n\n<span class="hljs-subst">${text}</span>`</span>
                }
                <span class="hljs-keyword">return</span> text
            }
            <span class="hljs-keyword">const</span> errors = []
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> cause <span class="hljs-keyword">of</span> node.errors) {
                <span class="hljs-keyword">const</span> formatted = format(cause)
                <span class="hljs-keyword">const</span> indented = formatted.replace(<span class="hljs-regexp">/^/gm</span>, <span class="hljs-string">'    '</span>)
                errors.push(<span class="hljs-string">`\ncause:\n\n<span class="hljs-subst">${indented}</span>\n`</span>)
            }
            <span class="hljs-keyword">const</span> repeated = node.duplicates.size + <span class="hljs-number">1</span>
            <span class="hljs-keyword">const</span> instance = Instances.get(node.error)
            <span class="hljs-keyword">const</span> properties = { ...instance.options.properties }
            <span class="hljs-keyword">if</span> (repeated != <span class="hljs-number">1</span>) {
                properties.repeated = repeated
            }
            <span class="hljs-keyword">const</span> stack = node.error.stack.replace(<span class="hljs-regexp">/[\s\S]*^stack:$/m</span>, <span class="hljs-string">'stack:'</span>)
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.keys(properties).length != <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">const</span> contextualized = Interrupt.JSON.stringify(properties)
                <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${node.error.name}</span>: <span class="hljs-subst">${instance.message}</span>\n\n<span class="hljs-subst">${properties}</span>\n\n<span class="hljs-subst">${errors.join(<span class="hljs-string">''</span>)}</span>\n\n<span class="hljs-subst">${stack}</span>`</span>
            }
            <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${node.error.name}</span>: <span class="hljs-subst">${instance.message}</span>\n\n<span class="hljs-subst">${errors.join(<span class="hljs-string">''</span>)}</span>\n\n<span class="hljs-subst">${stack}</span>`</span>
        }
        <span class="hljs-comment">/*
        function print (indent, extract, node) {
            console.log(`${indent}${util.inspect(extract(node), { depth: null, breakLength: Infinity })}`)
            if (node.errors != null &amp;&amp; node.errors.length != 0) {
                for (const cause of node.errors) {
                    print(`  ${indent}`, extract, cause)
                }
            }
        }*/</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trim</span> (<span class="hljs-params">node, parent</span>) </span>{
            <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) {
                parent.errors = parent.errors.filter(<span class="hljs-function"><span class="hljs-params">sibling</span> =&gt;</span> ! node.duplicates.has(sibling.id))
            }
            <span class="hljs-keyword">if</span> (node.errors != <span class="hljs-literal">null</span> &amp;&amp; node.errors.length != <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>
                <span class="hljs-keyword">while</span> (node.errors.length != i) {
                    trim(node.errors[i++], node)
                }
            }
        }
        <span class="hljs-keyword">const</span> tree = treeify(<span class="hljs-literal">null</span>, error)
        leafify(tree)
        mark(tree)</pre></div></div>

        </li>


        <li id="section-66">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>print(‘’, $ =&gt; [ $.id, 1 + $.duplicates.size ], tree)</p>

            </div>

            <div class="content"><div class='highlight'><pre>        trim(tree, <span class="hljs-literal">null</span>)</pre></div></div>

        </li>


        <li id="section-67">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>print(‘’, $ =&gt; [ $.id, 1 + $.duplicates.size ], tree)</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> format(tree)
    }
}</pre></div></div>

        </li>


        <li id="section-68">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>A valid JavaScript identifier. Taken from <a href="https://gist.github.com/mathiasbynens/6334847">this
gist</a> and used as a string for
inclusion into other regexen.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> identifier = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./identifier.json'</span>)

<span class="hljs-keyword">const</span> RE = {
    <span class="hljs-attr">identifier</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`^<span class="hljs-subst">${identifier}</span>$`</span>),
    <span class="hljs-attr">exceptionStart</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`^(\\s*)(<span class="hljs-subst">${identifier}</span>(?:\.<span class="hljs-subst">${identifier}</span>)*)(:)\\s([\\s\\S]*)`</span>, <span class="hljs-string">'m'</span>)
}

<span class="hljs-keyword">const</span> unstacker = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stacktrace-parser'</span>)

<span class="hljs-keyword">const</span> Dedents = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dedent</span> (<span class="hljs-params">line, depth, position</span>) </span>{
    <span class="hljs-keyword">if</span> (depth == <span class="hljs-number">0</span> || line.length == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> line
    }
    <span class="hljs-keyword">const</span> dedenter = Dedents.get(depth)
    <span class="hljs-keyword">if</span> (dedenter == <span class="hljs-literal">null</span>) {
        Dedents.set(depth, <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`^ {<span class="hljs-subst">${depth}</span>}(.*)$`</span>))
        <span class="hljs-keyword">return</span> dedent(line, depth, position)
    }
    <span class="hljs-keyword">const</span> $ = dedenter.exec(line)
    assert($ != <span class="hljs-literal">null</span>, <span class="hljs-string">'PARSE_ERROR'</span>, position)
    <span class="hljs-keyword">return</span> $[<span class="hljs-number">1</span>]
}

<span class="hljs-built_in">module</span>.exports = Interrupt</pre></div></div>

        </li>

    </ul>
  </div>
</body>
</html>
