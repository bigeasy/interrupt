<!DOCTYPE html>
<html>
<head>
  <title>Title</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha512-NhSC1YmyruXifcj/KFRWoC561YpHpc5Jtzgvbuzx5VozKpWvQ+4nXhPdFgmx8xqexRcpAglTj9sIBWINXa8x5w==" crossorigin="anonymous">
  <link href="https://fonts.googleapis.com/css?family=Inconsolata|Merriweather|Source+Sans+Pro|Mate|Offside|Raleway:400,700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Sorts+Mill+Goudy">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.1/styles/tomorrow-night.min.css" integrity="sha512-Ly91v1PH9MuXZoEzAV762yfHfn7sAaUHOrv5a3d27/Pk6trrRcEJTXQrU3lgxC/v4+CzRqAK68hnHnDx2agvng==" crossorigin="anonymous"><a href="https://github.com/bigeasy/interrupt/"><img style="position: fixed; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_gray_6d6d6d.png" alt="Fork me on GitHub"></a>
  <style type="text/css">
    body {
        display: flex;
        flex-direction: column;
        font-family: 'Source Sans Pro', Merriweather, Geneva, "Helvetica Neue", "Gill Sans", Geneva, Times, Georgia, Geneva, Avenir, "Helvetica Neue";
    }
    h1, h2 {
        font-family: Inconsolata;
    }
    h2.invocation {
      font-family: Inconsolata;
      border: 1px dotted gray;
      font-size: 0.95em;
      padding: 0.75em 1em 0.75em 1em;
    }
    div.container {
        width: 1000px;
    }
    div.definition {
      margin-left: 3em;
    }
    ul code {
        font-family: Inconsolata;
    }
    p code {
        font-family: Inconsolata;
        padding-left: 3px;
        padding-right: 3px;
        border: 1px dotted gray;
    }
    p {
        line-height: 1.4em;
    }
    ul {
        padding: 0;
        padding-left: 1em;
    }
    li {
        list-style: disc;
        line-height: 1.4em;
        margin-left: 0;
        margin-top: 0.25em;
        margin-bottom: 0.25em;
    }
    pre > code.hljs {
        font-family: Inconsolata;
        padding: 1em;
    }
    div {
        align-self: center;
    }
    table {
        border-collapse: collapse;
        align-self: center;
    }
    table tr td.ditto_x {
        padding: 3pt 12pt;
        text-align: center;
    }
    table tr.header td {
        font-family: 'Georgia';
        font-style: italic;
    }
    table tr.divider td {
        border-top: 1px solid black
    }
    table tr td.infinitive {
        font-weight: bold;
        padding-top: 24pt;
        font-family: 'Georgia';
        padding-bottom: 12pt;
        text-align: center;
        font-size: 1.35em;
    }
    table td {
        vertical-align: top;
        padding: 3pt 6pt;
        line-height: 1.25em;
    }
    div.definition p {
      text-align: justify;
    }
    div.definition li {
      text-align: justify;
    }
  </style>
<head>
<body>
  <div class="container">
  <h1>Interrupt</h1>
    <p><strong>TODO</strong> Minimal advocacy preamble. And for the rest of the
    document, there is a lot yet to do. It repeats the `readme.t.js`, a lot, and
    it is not very meaningful without code examples. The `readme.t.js` and this
    document should link back and forth.
    <p class="markdown">To learn how to use Interrupt in your program please use
    the [`readme.t.js`](docco/readme.t.js). This is the API documentation for
    Interrupt. It lays out the rules for Interrupt but it doesn't really cover
    the finder points of usage.
    <h2 class="invocation">UserError = Interrupt.create(className[, superClass ][, code |  codes{ name: prototype | message } | codes() | codes[] ]*)</h2>
    <div class="definition">
      <p>This variadic function accepts a required <code>className</code>,
      followed by an optional <code>superClass</code> followed by zero or many
      optional error code definitions.
      <ul class="parameters">
        <li>
          <code>className: String</code> &mdash;
          The class name. A dot separated valid path of valid JavaScript
          identifiers.
        </li>
        <li>
          <code>superClass: class Interrupt</code> &mdash;
          The optional super class of the generated class. The super class must
          be derived from `Interrupt`.
        </li>
        <li>
          <code>code: String</code> &mdash;
          A code name. The code will be constructed with an empty code
          prototype.
        </li>
        <li>
          <code>codes: Object{ name: prototype{} | message: String }</code> &mdash;
          An optional map of error codes. The property name is the code name.
          The property value can either be the default message property for the
          error or an object that contains the default properties for the error.
        </li>
        <li>
          <code>codes({ Codes, Aliases, Super: { Codes, Aliases })</code> &mdash;
          A code defintion function that can return any of of the code
          specification types. It receives an object that contains the set of
          codes defined so far in <code>Codes</code>, the set of aliases defined
          so far in <code>Aliases</code>, and the codes and aliases defined in
          the super class in <code>Super</code>.
        </li>
        <li>
          <code>codes[ code | codes{ name: prototype | message } | codes() | codes[] ]</code> &mdash;
          An array containing any of the code specification types. Allows for
          recursion or use of a set of predefined codes.
        </li>
      </ul>
      <p>Create a new error class derived from `Interrupt`. The class name is
      required and must be a valid JavaScript identifier or a dot separated path
      of valid JavaScript identifiers.

      <p>Code definition will register codes for the generated `Interrupt`
      object and and create associated `Symbols` for each code. Each code must
      be specified only once or else an exception is raised.

      <p>For each code a static property is added to the generated error class
      with the name of the code and the symbol for the code as a value.
    </div>
    <h2 class="invocation">userError = new UserError([ properties{} | [ code | message ] | error | errors[] | stackTraceLimit ]*)</h2>
    <div class="definition">
      <ul>
        <li>
          <code>properties{}</code> &dash;
          An object used to define options and additional properties to set on
          constructed error. If a property is one one of the special properties
          defined below, the given value will be set as a property on the
          constructed error. The property must be a valid JavaScript identifier
          or one of the special `#` prefixed properties. If a property is
          prefixed with an underscore `_` it will be used for `sprintf`
          formatting but not set as a property on the constructed error.
          <ul>
            <li>
              <code>code: String | Prototype</code> &mdash;
              The string name of a code to use as the prototype for the
              constructed error. The symbol of the associated code will be used to
              set the `symbol` property of the constructed error.
            <li>
              <code>message: String</code> &mdash;
              The `sprintf` message format used to set the `message` property of
              the generated error.
            <li>
              <code>errors[]</code> &mdash;
              An array of errors that will be added to the `errors` array property
              of the constructed error.
            <li>
              <code>'#type' | Interrupt.OPTIONS</code> &mdash;
              An optional type indicator that if given, must always have the value
              <code>Interrupt.OPTIONS</code>.
            <li>
              <code>'#errors' | Array</code> &mdash;
              An array of error objects that describe construction errors
              encountered while constructing the error itself.
            <li>
              <code>'#callee' | Function</code> &mdash;
              A function used to prune the stack trace, stack frames above the
              given callee will be removed from the stack trace using
              </code>Error.captureStackTrace()</code>.
          </ul>
        <li>
          <code>code | message : String</code> &mdash;
          The string code name or the code symbol of the code to assign to the
          exception. If the code is a string name and does not match the
          existing set of codes, the code is used as a `sprintf-js` formatted
          message format.
        <li>
          <code>error: Error</code> &mdash;
          An object that is `instanceof Error` that will be added to the array
          of nested property `errors` in the constructed object.
        <li>
          <code>errors[]</code> &mdash;
          An array of zero, one or more nested errors that represent the cause
          of the this exception used to set the `errors` property of the
          exception.
        <li>
          <code>stackTraceLimit: Integer | Infinity</code> &mdash;
          <code>Infinity</code> or on integer greater than or equal to zero. The
          stack trace limit used to generate the stack trace. If <code>0</code>
          the stack heading will not be displayed in the stack trace message of
          the generated error.
      </ul>
      <p>You can specify any of the arguments any number of times. The results
      are merged to create a final set of options used to create the constructed
      error. The `error` and `errors` arguments and the `errors` property of a
      `properties` object will be pushed onto a single array to create the array
      of nested errors used for the `errors` property of the constructed object.
      The `'#errors'` property of a `properties` object will also be pushed onto
      a single construction errors array. All other arguments arguments will
      override previous value specified if any.

      <p>The error constructor will not perform any assertions. It will not
      raise an excpetion if it incounters invalid arguments. It ignores
      arguments it cannot interpret or properties in the `properties` argument
      that are invalid (i.e. null, wrong type, etc.) Any errors encoutered
      during construction will be reported in the stack trace output in a
      construction errors section that follows the properties section of the
      stack trace message. An array of construction errors can also be obtained
      using `Interrupt.errors(error)`.

      <p>The `properties` are used to both specify options and set additional properties
      on the constructed error. Special properties will not be used to set
      properties on the constructed error. Additional properties must have valid
      JavaScript identifier names otherwise they are ignored and construction
      error is recorded.

      <p>Names in a `properties` object prefixed with an underscore `_` will not
      be set on the constructed error, but they will be available to `sprintf`
      to format the `message` property of the constructed error.

      <p>The `errors` property must be an array and can contain objects of any
      type, not just instances of `Error`.

      <p>The `#type` property is only useful in specifying currying to helper
      functions. **TODO** Just link to to the `readme.t.js`. To hard to explain.

      <p>The `'#errors'` array can be used by helper functions like `assert` to
      report construction errors encountered prior to calling the error
      constructor. A construction error should have string `code`, a
      non-enumberable `symbol` property whose value is a `Symbol` with a display
      name is the same as the code, a `message`. Any additional properites
      should be have JavaScript identifier names and JSON serializable values.
    </div>
    <h2 class="invocation">UserError.codes</h2>
    <div class="definition">
      <ul>
        <li><code>String[]</code> &mdash; The names of the error codes for the error.
      </ul>
      <p>An array containing the names of all the codes for the error.
    </div>
    <h2 class="invocation">UserError.&lt;USER_CODE&gt;</h2>
    <div class="definition">
      <ul><li><code>Symbol</code> &mdash; The symbol associated with a user defined error code.</ul>
      <p>A static property for each code defined in the `Interrupt.code()`
      declarator is defined on the generated error class. This symbol will be
      used to set the <code>symbol</code> property of constructed errors.
      <pre><code class="language-javascript hljs">
        const ConfigError = Interrupt.create('ConfigError', 'IO_ERROR')
        assert(typeof ConfigError.IO_ERROR === 'symbol')
      </code></pre>
    </div>
    <h2 class="invocation">Interrupt.Code(object{ code, symbol } | ( code, symbol ))</h2>
    <div class="definition">
      <ul>
        <li><code>object{ code: String, symbol: Symbol }</code> &mdash;
        An object whose <code>code</code> and <code>symbol</code> properties are
        used to construct a code object.
        <li><code>code: String</code> &mdash;
        The name of the code.
        <li><code>symbol: Symbol</code> &mdash;
        A symbol to associate with the code.
      </ul>
      <p>Construct a code object with an enumerable <code>code</code> name
      property and a non-enumerable <code>symbol</code> property for the code
      symbol.

      <p>This is a helper function to add additional codes to your constructed
      errors that you can test by symbol at runtime, but whose symbols will be
      excluded from JSON serialized output.
    </div>
    <h2 class="invocation">Interrupt.OPTIONS</h2>
    <div class="definition">
      <ul>
        <li>The value of `'#type'` in an options object.
      </ul>
      <p>When you construct an options object using
      <code>Interrupt.options()</code> the <code>'#type'</code> property is set
      to this symbol to unambiuously identify the object as an options object.
    </div>
    <h2 class="invocation">Interrupt.CURRY</h2>
    <div class="definition">
      <ul>
        <li><code>Object{ '#type': Interrupt.OPTIONS }</code> &mdash;
        An object containing a <code>'#type'</code> property with a value of
        <code>Interrupt.OPTIONS</code>.
      </ul>
      <p>A pre-constructed options object for use with user-defined helper
      functions to indicate that the helper function should be curried. An
      object with a `'#type'` property whose value is `Interrupt.OPTIONS` is an
      options object and cannot be mistaken for any other type.
    </div>
    <h2 class="invocation">Interrupt.message(error)</h2>
    <div class="definition">
      <ul>
        <li><code>error: Object</code> &mdash;
        Any value other than <code>null</code> or <code>undefined</code>.
      </ul>
      <p>If <code>error</code> is an instance of <code>Interrupt</code>,
      return the <code>sprintf</code> formatted error message without the
      additional stack trace formatted message. If `error` is any other object
      return the `message` property of that object.
    </div>
    <h2 class="invocation">Interrupt.parse(stack)</h2>
    <div class="definition">
      <ul>
        <li><code>stack: String</code> &mdash;
        A stack trace string from `Error.stack`.
      </ul>

      <p>Parse a stack trace from any <code>Error</code> instance. Returns an
      object with the error class, message and an array with the parsed stack
      trace. If the stack trace is from an instance of <code>Interrupt</code>
      or the result of calling <code>Interrupt.stringify()</code> on a
      non-Interrupt <code>Error</code> the resuling object tree will include
      enumerable <code>Error</code> properties and nested errors.
    </div>
    <h2 class="invocation">Interrupt.explode(error)</h2>
    <div class="definition">
      <ul>
        <li><code>error: Object</code> &mdash;
        Any value other than `null` or `undefined`.
      </ul>
      <p><strong>TODO</strong> Why not `null` or `undefined`. What if you pass
      in `1`. Can't we just JSON stringify and parse something?

      <p><strong>TODO</strong> Return the component parts and a flag instead
      of the array encasement.

      <p>Converts an <code>Error</code> into an object containing its component parts for
      serialization in the Interrupt serialization format or else returns an
      array containing the component parts if the Interrupt serialization
      would be malformed.
    </div>
    <h2 class="invocation">Interrupt.stringify(error)</h2>
    <div class="definition">
      <ul>
        <li><code>error: Error</code> &mdash;
        An instance of any class derived from <code>Error</code>.
      </ul>
      <p>Serialize the given `error` using the Interrupt serialization format.
      If `error` is an instance of `Interrupt`, simply return `error.stack`.
      Otherwise serialize the error using the Interrupt serialization format
      including enumerable properties and nested errors. If the `Error`
      properties would create a malformed Interrupt serialization, serialize the
      `Error` properties as JSON instead.
    </div>
    <h2 class="invocation">userError[util.inspect.custom](depth, options)</h2>
    <div class="definition">
      <ul>
        <li><code>depth: Integer</code> &mdash;
        The depth to recurse when serializing. (ignored)
        <li><code>options: Object</code> &mdash;
        The inspect options. (ignored)
      </ul>
      <p>Implements serialization used by `util.inspect`. `util.inspect` is used
      to dump the exception to standard error when an Node.js program has an
      uncaught exception or an unhandled rejection. `util.inspect` would
      ordinarily duplicate the dispaly of enumerable properties using its own
      unparsible serialization format. This implementation returns the parsible
      `error.stack` property of an instance of `Interrupt`.
    </div>
    <h2 class="invocation">userError.toString()</h2>
    <div class="definition">
      <p>Returns the generated class name and the `sprintf` formatted message
      spearated by a colon. Without overriding it, the full message with
      properties, nested errors and headings would be returned.
    </div>
  </div>
</body>
</html>
<!-- vim: set sw=2 ts=2: -->
